<!DOCTYPE html>
<meta charset="utf-8">

<html>
<head>
</head>

<script src="http://d3js.org/d3.v3.min.js"></script>

<link href="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.js" type="text/javascript"></script>

<style>

    /* This is for the lines because their value=10. Temporary. */
    .link10 {
        stroke: #ccc;
        stroke-width: 3px;
        stroke-dasharray: 3, 3;
    }

    /* Probably not be used now as far as I can tell ... */
    .link1 {
        stroke: #000;
        stroke-width: 3px;
    }

    .nodetext {
        pointer-events: none;
        font: 10px sans-serif;
    }

    /* Probably not used. */
    .node.type1 {
        fill:brown;
    }
    .node.type2 {
        fill:#337147;
    }
    .node.type3 {
        fill:blue;
    }
    .node.type4 {
        fill:red;
    }
    .node.type5 {
        fill:#1BC9E0;
    }
    .node.type6 {
        fill:#E01B98;
    }

    /* Probably not used. */
    image.circle {
        cursor:pointer;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%; /* aspect ratio */
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content-responsive {
        display: inline-block;
        position: absolute;
        top: 10px;
        left: 0;
    }

    /* This is for the tooltips. if no "width" and "height", it resizes automatically. */
    div.tooltip {
        position: absolute;
        text-align: center;
        /*
        width: 100px;
        height: 40px;
        */
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }

</style>

<script>
/*
AJOUTER:
- Undo edition.
- Mixer les SVG avec des graphes et des trees.
  Ou bien lier les nodes de facon rigide, matricielle. On les mettrait dans une classe specifique.
- A terme, pour les couleurs, ne pas utiliser le JSON mais charger le fichier CSS dans le directory de la classe.
- Afficher quelque chose quand le result "json" est vide.
- Afficher la meme chose en Graphviz: Pour ce faire, on pourrait injecter le reseau, en JSON dans un script
Python qui le retransformerait en RDF etc...
L'avantage est qu on peut tout afficher. En revanche, on perd la possibilite d'actualiser
une requete particulierement interessante. Notons qu en pratique, les requetes combinees ne sont pas encore
specifiees et seront surement tres differentes.

We wish to pass several parameters so that scripts and objects can be added or substracted,
with pattern matching possibilities.
Should we pass the arguments as GET or as a JSON document ?
This could assume the CGI structure:
"http://127.0.0.1:8000/survol_d3.htm?xid=CIM_Directory.Name=E%3A%2FHewlett-Packard%2FSystemDiags"

What about "+"/"-" ??

xxx.htm?xid=(XID1)&script=(SCRIPT1)&operator=+&xid=(XID2)&script=(SCRIPT2)

By default the operator is "+".

And also we need to restore merge_rdf_inputs_graphviz_only.htm,
in fact it can handle all modes, something like merger.py.
Its role is to produce a document based on several URLs.
And we will zap the files *merge*.htm .
Also, we must transmit to graphic properties for edges: This simply means having a specific object:
"COLLAPSED_PROPERTY" property "True"
... ou bien:
"PROPERTY_LAYOUT" property "Ortho"

paramsCgi = location.search;
alert("paramsCgi="+paramsCgi);
*/

var wScreen;
var hScreen;
var force = null;

// At startup.
var theurl = "htbin/sources_types/enumerate_CIM_Process.py?xid=.&mode=json";
// var theurl = "htbin/sources_types/CIM_Process/process_cwd.py?xid=CIM_Process.Handle%3D2976&mode=json";
// var theurl = "htbin/sources_types/enumerate_CIM_LogicalDisk.py?xid=.&mode=json";

// This returns the top-level options.
var urlTopLevel = "htbin/entity.py?mode=menu";

var divSvg = null;
var globalMustMerge = false;

// This stores the current nodes and links. Maybe there is a simpler way to store them.
var previousData = null;


// Sanity check to ensure that nodes and links are properly matched.
function CheckGraph(theNam,theData)
{
    return;
    if(theData == null)
    {
        return;
    }
    console.log(theNam+" nodes="+theData.nodes.length+" links="+theData.links.length);

    console.log("=================");
    for( var ix = 0; ix < theData.nodes.length; ix++ )
    {
        objNod = theData.nodes[ix]
        console.log("ix="+ix+" "+JSON.stringify(objNod));
    }
    console.log("=================");

    for( var ix = 0; ix < theData.links.length; ix++ )
    {
        if( theData.links[ix].source == undefined )
        {
            console.log("Undefined source ix="+ix);
        }
        if( theData.links[ix].source >= theData.nodes.length )
        {
            console.log("Too big source ix="+ix+" :"+theData.links[ix].source);
        }
        if( theData.links[ix].target == undefined )
        {
            console.log("Undefined target ix="+ix);
        }
        if( theData.links[ix].target >= theData.nodes.length )
        {
            console.log("Too big target ix="+ix+" :"+theData.links[ix].target);
        }

        // console.log("Check ix="+ix+" source="+theData.links[ix].source+" target="+theData.links[ix].target);
    }
    console.log("===============");
} // CheckGraph



// Mais pourquoi data est passe en premier ? au lieu de (error,data ) ?
// Ah peut-etre d2 version 2 au lieu de 4 ?
function CreateDisplay(data)
{
    if( data == null )
    {
        alert("CreateDisplay: Json data is null");
        return;
    }

    CheckGraph("new",data);

    //alert(JSON.stringify(data));
    var win = window,
        doc = document,
        elt = doc.documentElement,
        geb = doc.getElementsByTagName('body')[0];
    wScreen = win.innerWidth || elt.clientWidth || geb.clientWidth,
    hScreen = win.innerHeight|| elt.clientHeight|| geb.clientHeight;

    // http://stackoverflow.com/questions/16265123/resize-svg-when-window-is-resized-in-d3-js
    // This allows the resizing.
    divSvg = d3.select("body")
       .append("div")
       .classed("svg-container", true) //container class to make it responsive
       .append("svg:svg")
       //responsive SVG needs these 2 attributes and no width and height attr
       .attr("preserveAspectRatio", "xMinYMin meet")
       .attr("viewBox", "0 0 " + wScreen + " " + hScreen)
       //class to make it responsive
       .classed("svg-content-responsive", true)
        ;

    /*
    divSvg.append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("refX", 17 + 3) // must be smarter way to calculate shift
        .attr("refY", 2)
        .attr("markerWidth", 6)
        .attr("markerHeight", 4)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M 0,0 V 4 L6,2 Z"); //this is actual shape for arrowhead
    */

    force = d3.layout.force();

    previousData = data;
    FillDisplay(divSvg,previousData,wScreen,hScreen);
} // CreateDisplay

// Callback of contextual menu. It receives the JSON menu sent by the server.
function RefillDisplay(data)
{
    CheckGraph("new",data);
    if( data == null )
    {
        alert("RefillDisplay: Jason data is null");
        return;
    }

    if( globalMustMerge )
    {
        // This creates a new list of nodes with new numbers and without the duplicates.
        // The links also, are recreated, with new numbers.
        var previousNodes = previousData.nodes;
        var prevUrlsToIds = {};

        var lenPrevNodes = previousNodes.length;
        for (var ixNod = 0; ixNod < lenPrevNodes; ixNod++) {
            var urlNode = previousNodes[ixNod].survol_url;

            // Sanity check:
            if(prevUrlsToIds[urlNode] != undefined)
            {
                alert("prevUrlsToIds[urlNode] undefined. urlNode="+urlNode);
            }

            // Normally, at this stage, each URL should appear only once.
            prevUrlsToIds[urlNode] = ixNod;
        }

        console.log("prevUrlsToIds elements:"+JSON.stringify(prevUrlsToIds));

        // The new numbers of the new nodes are written in the nodes themselves.
        var newNodes = data.nodes;
        var lenNewNodes = newNodes.length;
        for( var ixNod = 0; ixNod < lenNewNodes; ixNod++ )
        {
            var newNod = newNodes[ixNod];
            var urlNode = newNod.survol_url;

            // Sanity check
            if( urlNode == undefined)
            {
                alert("urlNode undefined. ixNod="+ixNod);
            }

            // Index of the same URL in the current list of nodes.
            var oldIdx = prevUrlsToIds[urlNode];

            if( oldIdx == undefined )
            {
                // Most common case of a new node.
                idxAppend = previousNodes.length;
                // newNod.new_index = lenPrevNodes + ixNod;
                newNod.new_index = idxAppend;

                // Sanity check
                if( idxAppend < lenPrevNodes )
                {
                    alert("idxAppend="+idxAppend);
                }

                // The new node is copied at the end.
                previousNodes.push(newNod);
            }
            else
            {
                // The node already exists, no copy.
                newNod.new_index = oldIdx;

                // Sanity check
                if( previousNodes[oldIdx].survol_url != urlNode)
                {
                    alert("Inconsistent urls oldIdx="+oldIdx);
                }
            }
        }

        // Now we renumber the edges.
        var newLinks = data.links;
        var lenNewLinks = newLinks.length;
        var previousLinks = previousData.links;
        for( var ixLnk = 0; ixLnk < lenNewLinks; ixLnk++ )
        {
            var newLnk = newLinks[ixLnk];

            idxSourceMapped = newNodes[newLnk.source].new_index;

            // Sanity check
            if(idxSourceMapped == undefined)
            {
                alert("Source undefined newLnk.source="+newLnk.source);
            }

            newLnk.source = idxSourceMapped;

            idxTargetMapped = newNodes[newLnk.target].new_index;

            // Sanity check
            if(idxTargetMapped == undefined)
            {
                alert("Target undefined newLnk.target="+newLnk.target);
            }

            // console.log("Rewire "+ixLnk+" target from "+newLnk.target+" to "+idxTargetMapped);
            newLnk.target = idxTargetMapped;

            // Sanity check
            if(newLnk.source == undefined)
            {
                alert("newLnk.source undefined. ixLnk="+ixLnk);
            }
            if(newLnk.target == undefined)
            {
                alert("newLnk.target undefined. ixLnk="+ixLnk);
            }


            // If the source and the targets had to be remapped,
            // it means that the target was already there.
            // However, we insert it again because it should be rare,
            // and the duplicated edge might bring more information.
            previousLinks.push(newLnk);
        }

        // Now a last pass to remove the duplicate nodes.
        var ixNod = 0;
        while(ixNod < lenNewNodes)
        {
            var newNod = newNodes[ixNod];

            // Sanity check
            if(newNod.new_index == undefined)
            {
                alert("newNod.new_index undefined ixNod="+ixNod);
            }

            if(newNod.new_index < lenPrevNodes)
            {
                // The node already exists.
                newNod.new_index = oldIdx;
                newNodes.splice(ixNod,1); // Beware, this might be slow.
                console.log("Removing duplicate ixNod="+ixNod);
                lenNewNodes--;
            }
            else
            {
                ixNod++;
            }
        }

        // Sanity check
        if(lenNewNodes != data.nodes.length)
        {
            alert("Inconsistency lenNewNodes="+lenNewNodes+" data.nodes.length="+data.nodes.length);
        }

        // Sanity check.
        CheckGraph("prev",previousData);
    }
    else
    {
        // If this is not a merge but a brand new URLs.
        previousData = data;
    }

    EmptyDisplay();
    FillDisplay(divSvg,previousData,wScreen,hScreen,globalMustMerge);
    globalMustMerge = false;
} // RefillDisplay

function EmptyDisplay()
{
    var node = divSvg.selectAll("g.survol_node")
        .data([])
        .exit()
        .remove();

    var link = divSvg.selectAll(".survol_line")
        .data([])
        .exit()
        .remove();
} // EmptyDisplay

/* When deleting a node from the contextual menu. Deletes the nodes and its links. */
function DeleteSvgNode(objectSvg)
{
    // No need of a lookup because it happens just once.
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        if( previousData.nodes[ixNod].survol_url == objectSvg.survol_url )
        {
            goodNodeIdx = ixNod;
            console.log("DeleteSvgNode found ixNod="+ixNod);
            break;
        }
    }

    if(goodNodeIdx == undefined)
    {
        alert("Could not find url="+objectSvg.survol_url);
        return;
    }

    goodNode = previousData.nodes[goodNodeIdx];

    // The node is removed and the following node numbers are decremented.
    // Therefore the links must be updated.
    previousData.nodes.splice(goodNodeIdx,1);

    var lenLinks = previousData.links.length;
    var ixLnk = 0;
    console.log("DeleteSvgNode lenLinks="+lenLinks);
    while(ixLnk < lenLinks)
    {
        objLnk = previousData.links[ixLnk];

        // The link is pointing to the node to be deleted. Each index is replaced by the node itselfs
        // NOTE: APPARENTLY THE NODE INDICES ARE REPLACED BY THE NODE OBJECT.
        if( ( objLnk.source == goodNode ) || ( objLnk.target == goodNode ) )
        {
            previousData.links.splice(ixLnk,1);
            lenLinks--;
            continue;
        }

        ixLnk++;
    }
    console.log("DeleteSvgNode previousData.links.length="+previousData.links.length);

    EmptyDisplay();
    FillDisplay(divSvg,previousData,wScreen,hScreen,globalMustMerge);
    globalMustMerge = false;
} // DeleteSvgNode


function FillDisplay(divSvg,newData,w,h,mustMerge)
{
    console.log("newData.nodes="+newData.nodes.length+" newData.nodes="+newData.nodes.length);

    /*
    var force = d3.layout.force()
        .gravity(0.06)
        .charge(-150)
        .linkDistance(40)
        .size([w *= 2 / 3, h *= 2 / 3]);
    */

    force
        .nodes(newData.nodes)
        .links(newData.links)
        .distance(100)
        .charge(-1000)
        .linkDistance(100)
        .size([wScreen, hScreen])
        /*
        .distance(100)
        .charge(-1000)
        .size([wScreen, hScreen])
        */
        .start();

    // PROBABLEMENT OK POUR AJOUTER DES LINES.
    var link = divSvg.selectAll(".survol_line")
        .data(newData.links)
        .enter().append("svg:line")
        .attr("class", function (d) { return "link" + d.value + " survol_line"; }) // "link10"
        .attr("x1", function (d) { return d.source.x; })
        .attr("y1", function (d) { return d.source.y; })
        .attr("x2", function (d) { return d.target.x; })
        .attr("y2", function (d) { return d.target.y; })
        // "Error in parsing value for "markedr-end": This is why I removed this.
        // .attr("marker-end", function (d) { if (d.value == 1) { return "url(#arrowhead)"; } else { return " "; }; })
        // .append("svg:title").text(function(d) { return d.link_prop; })
        ;

    /*
    for( var ixNod = 0; ixNod < newData.nodes.length; ixNod++ )
    {
        newData[ixNod].bbox =
    }
    */

    // Creates one SVG object (Which class ?) for each survol node.
    // CA DEVRAIT ALLER POUR AJOUTER DES NODES.
    var selectedNodes = divSvg.selectAll("g.node")
        .data(newData.nodes)
        .enter().append("svg:g")
        .attr("class", function (d) { return "survol_node node"; }) // Two classes are possible.
        .call(force.drag);

    // fill:#337147;

    // Define the div for the tooltip.
    // If set globally, it is null here.
    var divToolTip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0.5)
        ;

    // Used for the tooltip containg literal nodes pointing to a given node, i.e. information.
    // TODO: This should be recursive.
    function DictToTable(theDict)
    {
        result = "<table>"
        for (var key in theDict) {
            if (theDict.hasOwnProperty(key)) {
                result += "<tr><td valign='top' align='left'><b>" + key + "</b></td><td valign='top' align='left'>" + theDict[key] + "</td></tr>";
            }
        }
        result += "</table>";
        return result;
    }


    // The class is a CSS style: ".node.type1" etc...

    function NodeLeftClick(d)
    {
        // This expects a graph, not a contextual menu.
        theurl = d.survol_url + "&mode=json";
        // alert("theurl="+theurl);
        d3.json(theurl, RefillDisplay);
    }

    function getTextBox(selection) {
        selection.each(function(d) { d.bbox = this.getBBox(); })
    }

    // This is the text associated to each survol node.
    selectedNodes.append("svg:text")
        .attr("class", "nodetext")
        .attr("dx", 0)
        .attr("dy", ".35em")
        .attr("text-anchor", "middle")
        .text(function (d) { return d.name; })
        .call(getTextBox)
    ;

    // Adds text inside each "g" object of class "survol_node": http://stackoverflow.com/questions/6725288/svg-text-inside-rect
    // d3.selectAll(".survol_node").append("rect")
    // Inserts the rect element before the text, which is therefore not hidden.
    d3.selectAll(".survol_node").insert("rect","text")
        .attr("x", function(d){return d.bbox.x})
        .attr("y", function(d){return d.bbox.y})
        .attr("width", function(d){return d.bbox.width})
        .attr("height", function(d){return d.bbox.height})
        // .style("opacity", ".3")
         /*
        .attr("width", 50)
        .attr("height", 20)
        */
        .style("stroke-width", 1)
        .style("stroke", "#000000")
        // Classes are not defined so fill colors are OK. We will fetch CSS in classes directories.
        .attr("fill", function (d) {
            /* #337147 */
            return d.fill;
        })
        .attr("class", function (d) { return d.entity_class; })
        //.attr("class", function (d) { return "node type" + d.type; })
        .on("mouseover", function(d)
            {
                // http://stackoverflow.com/questions/36326683/d3-js-how-can-i-set-the-cursor-to-hand-when-mouseover-these-elements-on-svg-co
                // This could as well be done in CSS, but we might wish not change
                // the pointer if no link is available, i.e. faulty node.
                d3.select(this).style("cursor", "pointer");

                divToolTip.transition()
                    .duration(200)
                    .style("opacity", .9);

                // d.survol_info is a dictionary.
                txtToolTip = DictToTable(d.survol_info);
                divToolTip.html( txtToolTip )
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 28) + "px")
                ;
                console.log("In mouseover d3.event.pageX="+d3.event.pageX+" d3.event.pageY="+d3.event.pageY);
            }
        )
        .on("mouseout", function(d)
            {
                // This could as well be done in CSS.
                d3.select(this).style("cursor", "default");

                divToolTip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }
        )
        .on("click", NodeLeftClick)
        ;

    // Maybe the click zone on each survol node ???????
    // Why is it invisible ??
    // Why not a "mousedown" ??
    /*
    selectedNodes.append("svg:image")
        .attr("class", "circle")
        .attr("xlink:href", function (d) { return d.img_href; })
        .attr("x", "-16px")
        .attr("y", "-16px")
        .attr("width", "32px")
        .attr("height", "32px")
        .on("click", NodeLeftClick);
    */

    var radius = d3.scale.log().domain([0, 312000]).range(["10", "50"]);

    // Is that to avoid collisions ?
    d3.selectAll(".circle").append("circle")
        .attr("class", function (d) { return "node type" + d.type; })
        .attr("r", function (d) { return radius(d.value) || 10; }).call(force.drag);



    function tick_function()
    {
        // Apply the constraints: On verra plus tard. http://bl.ocks.org/GerHobbelt/3669455

        link.attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });

        selectedNodes.attr("transform", function (d) {
            /*
            // Ca fonctionne mais ca n'est pas tres beau.
            var rr = 10;
            d.x = Math.max(rr, Math.min(w - rr, d.x));
            d.y = Math.max(rr, Math.min(h - rr, d.y));
            */

            // console.log("d.x="+d.x+" d.y="+d.y);
            return "translate(" + d.x + "," + d.y + ")";
        });

        // http://mbostock.github.io/d3/talk/20110921/bounding.html
        /*
        selectedNodes.attr("cx", function(d) { return d.x = Math.max(r, Math.min(w - r, d.x)); })
            .attr("cy", function(d) { return d.y = Math.max(r, Math.min(h - r, d.y)); });
        */
    }

    force.on("tick", tick_function);

    // This returns the contextual menu for nodes.
    function MakeContextMenuItems(objectSvg)
    {
        objUrl = objectSvg.survol_url;

        objKey = objectSvg.name;
        objDfd = objectSvg.dfd;
        console.log("MakeContextMenuItems objKey="+objKey);

        // https://swisnl.github.io/jQuery-contextMenu/demo/async-promise.html Submenu through promise.
        var menusSurvol = objDfd.promise();

        /* Peut-etre ajouter des URLs specifiques pour WMI et OpenWBEM ce qui justifierait qu'on aie
        des scripts Python specifiques.
        */

        TheItems = {};

        // This is the title, and it is clickable.
        TheItems[ objUrl ] =
        {
            name: objKey
        };

        // By default, results of scripts is merged with the current graph.
        TheItemsSuite =
        {
            "yesno": {
                name: "Merge graphs",
                type: 'checkbox',
                selected: true
            },
            "name": {
                name: "Si script, edit params",
                type: 'text',
                value: "Hello World",
                events: {
                    keyup: function(e) {
                        // add some fancy key handling here?
                        window.console && console.log('key: '+ e.keyCode);
                    }
                }
            },
            "sep1": "---------",
            "SurvolMenu": {
                name: "Related data...",
                items: menusSurvol,
            },
            "delete_node": {
                "name": "Delete node",
                "icon": "delete"
            },
            /*
            Delete connected to ?? Et from ??
            Ou alors on delete par type d'aretes ?
            */
            "delete_connected": {
                "name": "Delete connected nodes",
                "icon": "delete"
            }
        };

        jQuery.extend(TheItems, TheItemsSuite);

        return TheItems;
    } // MakeContextMenuItems

    // This returns the contextual menu for the background.
    function MakeDefaultContextMenuItems(objectSvg)
    {
        var theDfltItems =
        {
            "JaNein": {
                name: "Merge graphs",
                type: 'checkbox',
                selected: false
            },
            "xxxxx": {
                "name": "Sub group 2",
                "items": {
                    "edit": {"name": "Edit", "icon": "edit"},
                    "cut": {"name": "Cut", "icon": "cut", disabled: true},
                    "quit": {"name": "Quit", "icon": "quit"}
                }
            }
        };
        return theDfltItems;
     }


    // Called after the page is loaded. It adds a context menu to each node,
    // therefore the nodes must be created.
    function CreateContextMenus(){
        console.log("CreateContextMenus");

        function FromKeyToScript(key, options)
        {
            // We will merge the new content with the existing content or not.
            var menuOptions = {};
            $.contextMenu.getInputValues(options, menuOptions);
            globalMustMerge = menuOptions.yesno;

            // This is a Python script, but not a contextual menu displayed by "entity.py".
            theUrl = key + "&mode=json";
            console.log("theUrl="+theUrl);
            d3.json(theUrl, RefillDisplay);
        }


        $.contextMenu(
        {
            selector: 'g.survol_node',

            build: function($trigger, evt) {
                // This callback is executed every time the menu is to be shown
                // Its results are destroyed every time the menu is hidden
                // evt is the original contextmenu event, containing evt.pageX and evt.pageY (amongst other data)

                // In JSON format, the node on which we have right-clicked.
                var objectSvg = $trigger["0"]["__data__"];



                var theItems = MakeContextMenuItems(objectSvg);

                return {
                    // This is executed when an option is chosen in a contextual menu.
                    callback: function(key, options)
                    {
                        if(key == "delete_node")
                        {
                            // TODO: Have a specific callback.
                            DeleteSvgNode(objectSvg);
                        }
                        else if(key == "delete_connected")
                        {
                            alert("delete connected not implemented yet");
                        }
                        else
                        {
                            FromKeyToScript(key, options);
                            /*
                            // We will merge the new content with the existing content or not.
                            var menuOptions = {};
                            $.contextMenu.getInputValues(options, menuOptions);
                            globalMustMerge = menuOptions.yesno;


                            // This is a Python script, but not a contextual menu displayed by "entity.py".
                            theUrl = key + "&mode=json";
                            console.log("theUrl="+theUrl);
                            d3.json(theUrl, RefillDisplay);
                            */
                        }
                    },
                    items: theItems
                };
            }
        });

        var dfltItms = MakeDefaultContextMenuItems();

        /* There is one default menu, loaded once and for all,
        and it does not use the "promise" feature of the library.
        Therefore it is built asynchronously. */

        // Adds a context menu for the background.
        function AddsDefaultCtxtMenu(dfltItms)
        {
            console.log("AddsDefaultCtxtMenu");
            $.contextMenu(
            {
                selector: 'svg',
                build: function($trigger, evt) {

                    return {
                        callback: function(key, options)
                        {
                            FromKeyToScript(key, options);
                        },
                        items: dfltItms
                    };
                }
            });
        } // AddsDefaultCtxtMenu

        d3.json(urlTopLevel, AddsDefaultCtxtMenu);
    }; // CreateContextMenus


    // When the mouse right button is down, this loads the contextual menu content into the SVG object.
    // When this right button is released, it triggers the contextual menu which finds its content
    // stored in the SVG object.
    $("g.survol_node").mousedown(function(ev){
        /* Si clicke gauche, on va vers le "entity.py". */

        if(ev.which == 3)
        {
            var objectThis = this;
            function GetEntityUrl(jsonData)
            {
                // Maybe this duplicates the value. Not a problem.
                objectThis.__data__.contextual_menu_items = jsonData;

                objectThis.__data__.dfd.resolve(jsonData);
            }

            // We expect a contextual menu, not a graph.
            var urlEntity = this.__data__.survol_url + "&mode=menu";
            console.log("URL:"+urlEntity);

            this.__data__.dfd = jQuery.Deferred();

            d3.json(urlEntity, GetEntityUrl);
        }
    });

    // Call function after page load: http://stackoverflow.com/questions/890090/jquery-call-function-after-load
    $(CreateContextMenus);
} // FillDisplay

// alert("theurl="+theurl);
d3.json(theurl, CreateDisplay);

/*
http://bl.ocks.org/GerHobbelt/3669455
Rester dans la partie visible : Voir la fonction.
RDF doit passer la contrainte sur les propriétés: Ajouter des triplets RDF qui expriment le layout hierarchique:
« Layout »  property  « valeur »
Mais il n est pas certain que ca suffise quand on a beaucoup d’objets.
*/

</script>


<body>
Test D3


</body>
</html>
