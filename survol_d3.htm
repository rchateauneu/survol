<!DOCTYPE html>
<meta charset="utf-8">

<html>
<head>
</head>

<!-- Port to D3 v4 could be done by a specialist. -->
<!-- src="http://d3js.org/d3.v3.min.js" -->
<script src="d3.v3.min.js"></script>
<script src="base64.js"></script>

<!-- href="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.css" -->
<link href="jquery.contextMenu.css" rel="stylesheet" type="text/css" />
<!--  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js" -->
<script src="jquery.min.js"></script>
<!--  src="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.js" -->
<script src="jquery.contextMenu.js" type="text/javascript"></script>

<style>

    /* This is for the lines because their value=10. Temporary. */
    .link10 {
        stroke: #ccc;
        stroke-width: 3px;
        stroke-dasharray: 3, 3;
    }

    /* Probably not be used now as far as I can tell ... */
    .link1 {
        stroke: #000;
        stroke-width: 3px;
    }

    .nodetext {
        pointer-events: none;
        font: 10px sans-serif;
    }

    /* Probably not used. */
    .node.type1 {
        fill:brown;
    }
    .node.type2 {
        fill:#337147;
    }
    .node.type3 {
        fill:blue;
    }
    .node.type4 {
        fill:red;
    }
    .node.type5 {
        fill:#1BC9E0;
    }
    .node.type6 {
        fill:#E01B98;
    }

    /* Probably not used. */
    image.circle {
        cursor:pointer;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%; /* aspect ratio */
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content-responsive {
        display: inline-block;
        position: absolute;
        top: 10px;
        left: 0;
    }

    /* This is for the tooltips. if no "width" and "height", it resizes automatically. */
    div.tooltip {
        position: absolute;
        text-align: center;
        /*
        width: 100px;
        height: 40px;
        */
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }

</style>

<script>
/*
AJOUTER:
- Undo edition.
- Mixer les SVG avec des graphes et des trees.
  Ou bien lier les nodes de facon rigide, matricielle. On les mettrait dans une classe specifique.
- A terme, pour les couleurs, ne pas utiliser le JSON mais charger le fichier CSS dans le directory de la classe.
- Afficher quelque chose quand le result "json" est vide.
- Afficher la meme chose en Graphviz: Pour ce faire, on pourrait injecter le reseau, en JSON dans un script
Python qui le retransformerait en RDF etc...
L'avantage est qu on peut tout afficher. En revanche, on perd la possibilite d'actualiser
une requete particulierement interessante. Notons qu en pratique, les requetes combinees ne sont pas encore
specifiees et seront surement tres differentes.

We wish to pass several parameters so that scripts and objects can be added or substracted,
with pattern matching possibilities.
Should we pass the arguments as GET or as a JSON document ?
This could assume the CGI structure:
"http://127.0.0.1:8000/survol_d3.htm?xid=CIM_Directory.Name=E%3A%2FHewlett-Packard%2FSystemDiags"

What about "+"/"-" ??

xxx.htm?xid=(XID1)&script=(SCRIPT1)&operator=+&xid=(XID2)&script=(SCRIPT2)

By default the operator is "+".

And also we need to restore merge_rdf_inputs_graphviz_only.htm,
in fact it can handle all modes, something like merger.py.
Its role is to produce a document based on several URLs.
And we will zap the files *merge*.htm .
Also, we must transmit to graphic properties for edges: This simply means having a specific object:
"COLLAPSED_PROPERTY" property "True"
... ou bien:
"PROPERTY_LAYOUT" property "Ortho"

*/

/*
http://127.0.0.1:8000/htbin/sources_types/CIM_DataFile/file_stat.py?xid=CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29
http://127.0.0.1:8000/htbin/entity.py?xid=rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672

// The URLs list is something like that. It is not needed to split the xid.
[
    script="sources_types/CIM_DataFile/file_stat.py",
    xid:"CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29"
],
[
    script="entity.py"
    xid="rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],


ou tout simplement:
[
    urls:"sources_types/CIM_DataFile/file_stat.py?CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29",
    url:"entity.py?rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],

Ou meme:
[
    urls:"http://127.0.0.1:8000/sources_types/CIM_DataFile/file_stat.py?CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29",
    url:"http://127.0.0.1:8000/entity.py?rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],

A terme:
- En theorie, un URL peut etre utilise sur plusieurs machines et donner le meme resultat si on ajoute le host.
Donc on pourrait executer le meme script sur plusieurs machines. Ou suivre le meme objet sur plusieurs machines.
Et donc on reecrirait l'URL.
- On peut vouloir executer tous les scripts relatifs a un objet (On liste tous les scripts).
*/
function GetCgiParams()
{
    // console.log("resetParams");
    var query = window.location.search;
    var regex = /[?&;](.+?)=([^&;]+)/g;
    var match;

    var params = [];

    if (query) {
        while (match = regex.exec(query))
        {
            // There might be "=" equal signs in the value of the CGI variable.
            // "http://127.0.0.1:8000/htbin/sources_types/CIM_Directory/file_directory.py?xid=CIM_Directory.Name=E%3A%2FHewlett-Packard%2FSystemDiags"
            cgiObj = { cgi_key: match[1], cgi_value: decodeURIComponent(match[2])};

            params.push(cgiObj);
        }
    }
    return params;
}; // GetCgiParams


var wScreen;
var hScreen;
var myForce = null;

var divSvg = null;
var globalMustMerge = false;

// This stores the current nodes and links. Maybe there is a simpler way to store them.
var previousData = null;

var divTooltip = null;

// https://stackoverflow.com/questions/41705135/how-to-disable-mouseover-and-mouseout-event-while-dragging-with-d3
var isDragging = false;

// Sanity check to ensure that nodes and links are properly matched.
function CheckGraph(theNam,theData)
{
    'use strict';
    return;
    if(theData == null)
    {
        return;
    }
    console.log(theNam+" nodes="+theData.nodes.length+" links="+theData.links.length);

    console.log("=================");
    for( var ix = 0; ix < theData.nodes.length; ix++ )
    {
        objNod = theData.nodes[ix]
        console.log("ix="+ix+" "+JSON.stringify(objNod));
    }
    console.log("=================");

    for( var ix = 0; ix < theData.links.length; ix++ )
    {
        if( theData.links[ix].source == undefined )
        {
            console.log("Undefined source ix="+ix);
        }
        if( theData.links[ix].source >= theData.nodes.length )
        {
            console.log("Too big source ix="+ix+" :"+theData.links[ix].source);
        }
        if( theData.links[ix].target == undefined )
        {
            console.log("Undefined target ix="+ix);
        }
        if( theData.links[ix].target >= theData.nodes.length )
        {
            console.log("Too big target ix="+ix+" :"+theData.links[ix].target);
        }

        // console.log("Check ix="+ix+" source="+theData.links[ix].source+" target="+theData.links[ix].target);
    }
    console.log("===============");
} // CheckGraph



// Mais pourquoi data est passe en premier ? au lieu de (error,data ) ?
// Ah peut-etre d2 version 2 au lieu de 4 ?
function CreateDisplay(data)
{
    'use strict';

    function MyZoom() {
        divSvg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    }

    if( data == null )
    {
        alert("CreateDisplay: Json data is null");
        return;
    }

    CheckGraph("new",data);

    //alert(JSON.stringify(data));
    var win = window,
        doc = document,
        elt = doc.documentElement,
        geb = doc.getElementsByTagName('body')[0];

    // First defined and non-zero values.
    wScreen = win.innerWidth || elt.clientWidth || geb.clientWidth,
    hScreen = win.innerHeight|| elt.clientHeight|| geb.clientHeight;

    // http://stackoverflow.com/questions/16265123/resize-svg-when-window-is-resized-in-d3-js
    // This allows the resizing.
    divSvg = d3.select("body")
        .append("div")
        .classed("svg-container", true) //container class to make it responsive
        .append("svg:svg")
        //responsive SVG needs these 2 attributes and no width and height attr
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", "0 0 " + wScreen + " " + hScreen)

        // style="border-style:solid;border-width:1px;"
        .attr("style","border-style:solid;border-width:1px;")

        //class to make it responsive
        .classed("svg-content-responsive", true)
        // SVG Geometric Zooming https://bl.ocks.org/mbostock/3680999
        .call(d3.behavior.zoom().scaleExtent([0.125, 8]).on("zoom", MyZoom))
        ;

    /*
    divSvg.append("defs").append("marker")
        .attr("id", "arrowhead")
        .attr("refX", 17 + 3) // must be smarter way to calculate shift
        .attr("refY", 2)
        .attr("markerWidth", 6)
        .attr("markerHeight", 4)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M 0,0 V 4 L6,2 Z"); //this is actual shape for arrowhead
    */

    myForce = d3.layout.force();

	/*
	// Temp, to set initial position.
    for( var ix = 0; ix < data.nodes.length; ix++ )
    {
        var objNod = data.nodes[ix]
        if( ix < 3)
        {
            objNod.x = wScreen/2;
            objNod.y = hScreen/2;
            objNod.fixed = true;
        }
        else
        {
            objNod.x = wScreen/2;
            objNod.y = hScreen/2;
        }
    }
	*/


    previousData = data;
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
} // CreateDisplay

// Callback of contextual menu. It receives the JSON menu sent by the server.
function RefillDisplay(data)
{
    'use strict';
    CheckGraph("new",data);
    if( data == null )
    {
        alert("RefillDisplay: Jason data is null");
        return;
    }

    // If we merge the current nodes and links with the new one.
    if( globalMustMerge )
    {
        // This creates a new list of nodes with new numbers and without the duplicates.
        // The links also, are recreated, with new numbers.
        var previousNodes = previousData.nodes;
        var prevUrlsToIds = {};

        var lenPrevNodes = previousNodes.length;
        for (var ixNod = 0; ixNod < lenPrevNodes; ixNod++) {
            var urlNode = previousNodes[ixNod].survol_url;

            // Sanity check:
            if(prevUrlsToIds[urlNode] != undefined)
            {
                alert("prevUrlsToIds[urlNode] undefined. urlNode="+urlNode);
            }

            // Normally, at this stage, each URL should appear only once.
            prevUrlsToIds[urlNode] = ixNod;
        }

        // console.log("prevUrlsToIds elements:"+JSON.stringify(prevUrlsToIds));

        // The new numbers of the new nodes are written in the nodes themselves.
        var newNodes = data.nodes;
        var lenNewNodes = newNodes.length;
        for( var ixNod = 0; ixNod < lenNewNodes; ixNod++ )
        {
            var newNod = newNodes[ixNod];
            var urlNode = newNod.survol_url;

            // Sanity check
            if( urlNode == undefined)
            {
                alert("urlNode undefined. ixNod="+ixNod);
            }

            // Index of the same URL in the current list of nodes.
            var oldIdx = prevUrlsToIds[urlNode];

            if( oldIdx == undefined )
            {
                // Most common case of a new node.
                var idxAppend = previousNodes.length;
                newNod.new_index = idxAppend;

                // Sanity check
                if( idxAppend < lenPrevNodes )
                {
                    alert("idxAppend="+idxAppend);
                }

                // The new node is copied at the end.
                previousNodes.push(newNod);
            }
            else
            {
                // The node already exists, no copy.
                newNod.new_index = oldIdx;

                // Sanity check
                if( previousNodes[oldIdx].survol_url != urlNode)
                {
                    alert("Inconsistent urls oldIdx="+oldIdx);
                }
            }
        }

        // Now we renumber the edges.
        var newLinks = data.links;
        var lenNewLinks = newLinks.length;
        var previousLinks = previousData.links;
        for( var ixLnk = 0; ixLnk < lenNewLinks; ixLnk++ )
        {
            var newLnk = newLinks[ixLnk];

            var idxSourceMapped = newNodes[newLnk.source].new_index;

            // Sanity check
            if(idxSourceMapped == undefined)
            {
                alert("Source undefined newLnk.source="+newLnk.source);
            }

            newLnk.source = idxSourceMapped;

            var idxTargetMapped = newNodes[newLnk.target].new_index;

            // Sanity check
            if(idxTargetMapped == undefined)
            {
                alert("Target undefined newLnk.target="+newLnk.target);
            }

            // console.log("Rewire "+ixLnk+" target from "+newLnk.target+" to "+idxTargetMapped);
            newLnk.target = idxTargetMapped;

            // Sanity check
            if(newLnk.source == undefined)
            {
                alert("newLnk.source undefined. ixLnk="+ixLnk);
            }
            if(newLnk.target == undefined)
            {
                alert("newLnk.target undefined. ixLnk="+ixLnk);
            }


            // If the source and the targets had to be remapped,
            // it means that the target was already there.
            // However, we insert it again because it should be rare,
            // and the duplicated edge might bring more information.
            previousLinks.push(newLnk);
        }

        // Now a last pass to remove the duplicate nodes.
        var ixNod = 0;
        while(ixNod < lenNewNodes)
        {
            var newNod = newNodes[ixNod];

            // Sanity check
            if(newNod.new_index == undefined)
            {
                alert("newNod.new_index undefined ixNod="+ixNod);
            }

            if(newNod.new_index < lenPrevNodes)
            {
                // The node already exists.
                newNod.new_index = oldIdx;
                newNodes.splice(ixNod,1); // Beware, this might be slow.
                console.log("Removing duplicate ixNod="+ixNod);
                lenNewNodes--;
            }
            else
            {
                ixNod++;
            }
        }

        // Sanity check
        if(lenNewNodes != data.nodes.length)
        {
            alert("Inconsistency lenNewNodes="+lenNewNodes+" data.nodes.length="+data.nodes.length);
        }

        // Sanity check.
        CheckGraph("prev",previousData);
    }
    else
    {
        // If this is not a merge but a brand new URLs.
        previousData = data;
    }

    EmptyDisplay();
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
    globalMustMerge = false;
} // RefillDisplay

function EmptyDisplay()
{
    'use strict';
    var node = divSvg.selectAll("g.survol_node")
        .data([])
        .exit()
        .remove();

    var link = divSvg.selectAll(".survol_line")
        .data([])
        .exit()
        .remove();
} // EmptyDisplay

/* When deleting a node from the contextual menu. Deletes the nodes and its links. */
function FindIndexFromNode(objectSvg)
{
    'use strict';
    // No need of a lookup because it happens just once.
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        var goodNodeIdx;
        if( previousData.nodes[ixNod].survol_url == objectSvg.survol_url )
        {
            goodNodeIdx = ixNod;
            console.log("FindIndexFromNode found ixNod="+ixNod);
            return goodNodeIdx;
        }
    }

    alert("Could not find url="+objectSvg.survol_url);
    return -1;
} // FindIndexFromNode


/* When deleting a node from the contextual menu. Deletes the nodes and its links. */
function DeleteSvgNode(objectSvg)
{
    'use strict';
    var goodNodeIdx = FindIndexFromNode(objectSvg);
    var goodNode = previousData.nodes[goodNodeIdx];

    // The node is removed and the following node numbers are decremented.
    // Therefore the links must be updated.
    previousData.nodes.splice(goodNodeIdx,1);

    var lenLinks = previousData.links.length;
    var ixLnk = 0;
    console.log("DeleteSvgNode lenLinks="+lenLinks);
    while(ixLnk < lenLinks)
    {
        var objLnk = previousData.links[ixLnk];

        // The link is pointing to the node to be deleted. Each index is replaced by the node itselfs
        // NOTE: APPARENTLY THE NODE INDICES ARE REPLACED BY THE NODE OBJECT.
        if( ( objLnk.source == goodNode ) || ( objLnk.target == goodNode ) )
        {
            previousData.links.splice(ixLnk,1);
            lenLinks--;
            continue;
        }

        ixLnk++;
    }
    console.log("DeleteSvgNode previousData.links.length="+previousData.links.length);

    EmptyDisplay();
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
    globalMustMerge = false;
} // DeleteSvgNode

// NOT USED YET.
function MarkToDel(flag)
{
    'use strict';
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        previousData.nodes[ixNod].to_delete = flag;
    }
    for( var ixLnk = 0; ixLnk < previousData.links.length; ixLnk++ )
    {
        previousData.links[ixLnk].to_delete = flag;
    }
}

// NOT USED YET.
// There is no direct way to get the edges connected to one node,
// so this recursively explores the graph and marks objects for deletion.
function DeleteSvgConnectedNodes(objectSvg)
{
    'use strict';

    MarkToDel(false);

    // First, builds for each node, the list of edges starting from it.
    var dictNodeIdxToEdgesList = {};

    for( var ixLnk = 0; ixLnk < previousData.links.length; ixLnk++ )
    {
        var objLnk = previousData.links[ixLnk];
        /////////// dictNodeIdxToEdgesList[objLnk.source] ..... ixLnk ;
        /////////// dictNodeIdxToEdgesList[objLnk.target] ..... ixLnk ;
    }

    var listConnectedNodes = [];

    function RecursAppendConnected(idxNod)
    {
        var lstIdxEdges = dictNodeIdxToEdgesList[idxNod];
        for( var ixEdgeKey in lstIdxEdges )
        {
            var ixEdgeIdx = lstIdxEdges[ixEdgeKey];
            var objLnk = previousData.links[ixEdgeIdx];
            if( objLnk.to_delete ) {
                alert("We have a problem");
            }
            var idxTargetNod = objLnk.target;
            if( previousData.nodes[idxTargetNod].to_delete == false )
            {
                previousData.nodes[idxTargetNod].to_delete = true;
                objLnk.to_delete = true;
                listConnectedNodes.add(idxTargetNod);
                RecursAppendConnected(idxTargetNod);
            }
        }
    } // RecursAppendConnected


    var goodNodeIdx = FindIndexFromNode(objectSvg);

    RecursAppendConnected(goodNodeIdx);

    // Now we just need to delete.


    // HONEST: IT WOULD BE SIMPLER IF INDEXING WITH THE URLs ??

} // DeleteSvgConnectedNodes

/* Loads from a URL, a JSON document made of nodes and links.
After that, updates a table containing the list of loaded URLs. */
function LoadUrlUpdateDisplay(theUrl,funcDisplay,shouldMerge)
{
    'use strict';

    function AppendRow(col1,col2,col3)
    {
        var newLine = '<tr>'
            + '<td>' + col1 + '</td>'
            + '<td>' + col2 + '</td>'
            + '<td>' + col3 + '</td>'
            + '</tr>';
        $('#UrlsList').append(newLine);
    }

    function LoaderCallback(data)
    {
        if( data == null )
        {
            console.log("LoaderCallback: data is null");
            return;
        }
        funcDisplay(data);

        if( ! shouldMerge )
        {
            $('#UrlsList').empty();
            AppendRow("Title","Nodes","Links");
        }

        /*
        TODO: Add a tag to each node, so it is possible to hide or delete nodes
        coming from each URL.
        */

        AppendRow(data.page_title,data.nodes.length,data.links.length);
    }

    console.log("LoadUrlUpdateDisplay theUrl="+theUrl);

    if(isDragging) {
        console.log("NoUrl loading when dragging");
        return;
    }

    // Removes immediately tooltip if it is here.
    if(divTooltip) {
        divTooltip.style("opacity", 0);
    }

    d3.json(theUrl,LoaderCallback);
} // LoadUrlUpdateDisplay

function DisplayD3Layout(divSvg,newData,w,h)
{
    'use strict';
    console.log("newData.nodes="+newData.nodes.length+" newData.nodes="+newData.nodes.length);

    function tick_function()
    {
        /* Apply the constraints: On verra plus tard.
        using layout.force to plot tree graphs (where nodes may have multiple parents) - Part 1: pure tree
        http://bl.ocks.org/GerHobbelt/3669455
        */

        link.attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });

        // http://mbostock.github.io/d3/talk/20110921/bounding.html
        selectedNodes.attr("transform", function (d) {
            /*
            // Ca fonctionne mais ca n'est pas tres beau.
            var rr = 10;
            d.x = Math.max(rr, Math.min(w - rr, d.x));
            d.y = Math.max(rr, Math.min(h - rr, d.y));
            */

            return "translate(" + d.x + "," + d.y + ")";
        });
    }

    // It is possible to link nodes by names in D3 v4: https://bl.ocks.org/mbostock/533daf20348023dfdd76
    myForce
        .nodes(newData.nodes)
        .links(newData.links)
        .distance(100)
        .charge(-1000)
        .linkDistance(100)
        .size([wScreen, hScreen])
        .on("tick", tick_function)
        .start();

    var link = divSvg.selectAll(".survol_line")
        .data(newData.links)
        .enter().append("svg:line")
        .attr("class", function (d) { return "link" + d.value + " survol_line"; }) // "link10"
        .attr("x1", function (d) { return d.source.x; })
        .attr("y1", function (d) { return d.source.y; })
        .attr("x2", function (d) { return d.target.x; })
        .attr("y2", function (d) { return d.target.y; })
        // "Error in parsing value for "markedr-end": This is why I removed this.
        // .attr("marker-end", function (d) { if (d.value == 1) { return "url(#arrowhead)"; } else { return " "; }; })
        // .append("svg:title").text(function(d) { return d.link_prop; })
        ;

    // Creates one SVG object (Which class ?) for each survol node.
    // CA DEVRAIT ALLER POUR AJOUTER DES NODES.
    var selectedNodes = divSvg.selectAll("g.node")
        .data(newData.nodes)
        .enter().append("svg:g")
        .attr("class", function (d) { return "survol_node node"; }) // Two classes are possible.
        .call(myForce.drag);

	/* https://stackoverflow.com/questions/30723592/prevent-click-action-when-dragging-a-d3-node
	When combining drag with other event listeners,
	stop propagation on the source event to prevent multiple actions.
	Otherwise, dragging also triggers the click behavior when the mouse is released. */

    // var d3BehDrag = d3.behavior.drag();
    var d3BehDrag = myForce.drag();
    d3BehDrag
        .on("dragstart", function() {
            isDragging = true; // This avoids the tooltip when dragging.
            console.log("Tooltip disabled");
        })
        .on("dragend", function() {
            d3.event.sourceEvent.stopPropagation(); // silence other listeners
            isDragging = false; // Tooltip when hovering is now allowed.
            console.log("Tooltip enabled");
        })
        ;

    // fill:#337147;

    // Define the div for the tooltip.
    // If set globally, it is null here.
    divTooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0.5)
        ;

    // Used for the tooltip containg literal nodes pointing to a given node, i.e. information.
    // TODO: This should be recursive.
    function DictToTable(theList,theDict)
    {
        var result = "<table>"
        for (var ix in theList) {
            result += "<tr><td valign='top' align='left' colspan='2'><b>" + theList[ix] + "</td></tr>";
        }
        for (var key in theDict) {
            if (theDict.hasOwnProperty(key)) {
                result += "<tr><td valign='top' align='left'><b>" + key + "</b></td><td valign='top' align='left'>" + theDict[key] + "</td></tr>";
            }
        }
        result += "</table>";
        return result;
    }

    // https://bl.ocks.org/mbostock/7555321 Wrapping Long Labels
    function addTextLines(selection) {
        selection.each(function(d) {
            var theText = d3.select(this)
            theText.text(null).append("tspan").attr("x", 0).text(d.name);
            var cntLine = 0;

            for (var ix in d.survol_info_list) {
                theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(d.survol_info_list[ix]);
            }

            for (var key in d.survol_info_dict) {
                if (d.survol_info_dict.hasOwnProperty(key)) {
                    var txtKeyVal = key + "=" + d.survol_info_dict[key];
                    theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(txtKeyVal);
                }
            }

            // info_list
            // theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(d.name);
        })
    }

    function getTextBox(selection) {
        selection.each(function(d) { d.bbox = this.getBBox(); })
    }

    // This is the text associated to each survol node.
    selectedNodes.append("svg:text")
        .attr("class", "nodetext")
        .attr("dx", 0)
        .attr("dy", ".35em")
        .attr("text-anchor", "middle")
        // .text(function (d) { return d.name; }) // Use tspan and tref ???
        // .text(function (d) { return '<tspan>' + d.name + '</tspan><tspan dy="10">First line.</tspan>'; }) // Use tspan and tref ???
        .call(addTextLines)
        .call(getTextBox)
    ;

    // Adds text inside each "g" object of class "survol_node": http://stackoverflow.com/questions/6725288/svg-text-inside-rect
    // Inserts the rect element before the text, which is therefore not hidden.
    d3.selectAll(".survol_node").insert("rect","text")
        .attr("x", function(d){return d.bbox.x})
        .attr("y", function(d){return d.bbox.y})
        .attr("width", function(d){return d.bbox.width})
        .attr("height", function(d){return d.bbox.height})
        .style("stroke-width", 1)
        .style("stroke", "#000000")
        // Classes are not defined so fill colors are OK. We will fetch CSS in classes directories.
        .attr("fill", function (d) {
            /* #337147 */
            return d.fill;
        })
        .attr("class", function (d) { return d.entity_class; })
        //.attr("class", function (d) { return "node type" + d.type; })
        .on("mouseover", function(d)
            {
                // No tooltip creation when dragging because it is very CPU-consuming.
                if(isDragging) {
                    console.log("No tooltip when dragging");
                    return;
                }
                d.is_mouseover = true;

                // Loading a URL is very heavy. Maybe we should wait some tenths of seconds to check
                // if we are still on this node, before loading the tooltip.
                function IfMouseOver(d,currentEventD3pageX,currentEventD3pageY)
                {
                    if( false == d.is_mouseover ) {
                        console.log("MouseOver too late");
                        return;
                        }
                    if( isDragging ) {
                        console.log("IfMouseOver not when dragging");
                        return;
                        }

                    // d.survol_info_dict is a dictionary, and survol_info_list is a list.
                    // These two members are filled when parsing the input JSON document.
                    var urlTooltip = d.survol_url.replace("entity.py","entity_info_only.py")+"&mode=json";

                    d3.json(urlTooltip,
                        function(objTooltip)
                        {
                            if( false == d.is_mouseover ) {
                                console.log("After tooltip loaded: too late");
                                return;
                                }

                            if( isDragging ) {
                                console.log("No tooltip when dragging");
                                return;
                                }

                            if( objTooltip == null ) return ;
                            if( typeof(objTooltip.nodes) == 'undefined' ) return ;
                            if( typeof(objTooltip.nodes[0]) == 'undefined' ) return ;

                            // THIS MUST BE REPLACED BECAUSE UGLY AND NOT FLEXIBLE.
                            var objInfo = objTooltip.nodes[0].survol_info_dict
                            if ( typeof(objInfo) != 'undefined')
                            {
                                var txtTooltip = DictToTable([],objInfo);
                                console.log("txtTooltip="+txtTooltip);

                                // http://stackoverflow.com/questions/36326683/d3-js-how-can-i-set-the-cursor-to-hand-when-mouseover-these-elements-on-svg-co
                                // This could as well be done in CSS, but we might wish not change the pointer if no link is available, i.e. faulty node.
                                d3.select(this).style("cursor", "pointer");

                                divTooltip.transition()
                                    .duration(200)
                                    .style("opacity", .9);

                                divTooltip.html( txtTooltip )
                                    .style("left", (currentEventD3pageX) + "px")
                                    .style("top", (currentEventD3pageY - 28) + "px");
                            }
                        }
                    );
				} // IfMouseOver

                var currentEventD3 = d3.event;

                // Tooltip starts only after 500 milliseconds.
				setTimeout( function() { IfMouseOver(d,currentEventD3.pageX,currentEventD3.pageY); } , 500 );
            }
        )
        .on("mouseout", function(d)
            {
            console.log("Resetting MouseOver");
                d.is_mouseover = false;

                // This could as well be done in CSS.
                d3.select(this).style("cursor", "default");

                divTooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }
        )
        .on("click", function(d)
            {
                // TODO: Disabled for the moment because we do not know how to
                // make it work with drag.
                // This option is not mandatory because it is still possible to right-click.
                console.log("CLICK is disabled");
                return;


                // Removes immediately tooltip if it is here.
                // divTooltip.style("opacity", 0);

                // This expects a graph, not a contextual menu.
                var aUrl = d.survol_url + "&mode=json";
                // alert("aUrl="+aUrl);
                LoadUrlUpdateDisplay(aUrl, RefillDisplay,globalMustMerge);
            })
        ;

    var radius = d3.scale.log().domain([0, 312000]).range(["10", "50"]);

    // Is that to avoid collisions ? Is the drag needed here ?
    d3.selectAll(".circle").append("circle")
        .attr("class", function (d) { return "node type" + d.type; })
        // TODO: No change when it is commented out.
        //.attr("r", function (d) { return radius(d.value) || 10; })
        .call(myForce.drag);

    // This returns the contextual menu for nodes.
    function MakeContextMenuItems(objectSvg)
    {
        // SHOULD CALL entity_info_only.py BUT THE PROBLEM IS THAT IT IS NOT THE ORIGINAL NODE
        // SO THERE IS A CONFUSION WITH entity.py THAT EVERYTHING RELIES ON.
        // ALSO, WHEN mode=json WE SHOULD NOT DISPLAY THE WBEM AND WMI LINKS AND THE SCRIPTS.
        // MAYBE A ANOTHER MODE NEEDED FOR JUST TEXT INFORMATION FOR THE TOOLTIP.
        // BUT THIS IS VERY HEAVY TO CALL THIS EACH TIME WE HOVER OVER A NODE.
        var objUrl = objectSvg.survol_url;

        var objKey = objectSvg.name;
        var objDfd = objectSvg.dfd;
        console.log("MakeContextMenuItems objKey="+objKey);

        // https://swisnl.github.io/jQuery-contextMenu/demo/async-promise.html Submenu through promise.
        var menusSurvol = objDfd.promise();

        /* Peut-etre ajouter des URLs specifiques pour WMI et OpenWBEM ce qui justifierait qu'on aie
        des scripts Python specifiques.
        */

        var TheItems = {};

        // This is the title, and it is clickable.
        TheItems[ objUrl ] =
        {
            name: objKey
        };

        // By default, results of scripts is merged with the current graph.
        var TheItemsSuite =
        {
            "yesno": {
                name: "Merge graphs",
                type: 'checkbox',
                selected: true
            },
            "name": {
                name: "Si script, edit params",
                type: 'text',
                value: "Hello World",
                events: {
                    keyup: function(e) {
                        // add some fancy key handling here?
                        window.console && console.log('key: '+ e.keyCode);
                    }
                }
            },
            "sep1": "---------",
            "SurvolMenu": {
                name: "Related data...",
                items: menusSurvol,
            },
            "delete_node": {
                "name": "Delete node",
                "icon": "delete"
            },
            /*
            Delete connected to ?? Et from ??
            Ou alors on delete par type d'aretes ?
            */
            "delete_connected": {
                "name": "Delete connected nodes",
                "icon": "delete"
            }
        };

        jQuery.extend(TheItems, TheItemsSuite);

        return TheItems;
    } // MakeContextMenuItems

    // This returns the contextual menu for the background.
    function MakeDefaultContextMenuItems(objectSvg)
    {
        var theDfltItems =
        {
            "xxxx": {
                name: "xxxx",
                type: 'checkbox',
                selected: false
            },
            "yyyy": {
                "name": "yyyyy",
                "items": {
                    "edit": {"name": "Edit", "icon": "edit"},
                    "cut": {"name": "Cut", "icon": "cut", disabled: true},
                    "quit": {"name": "Quit", "icon": "quit"}
                }
            }
        };
        return theDfltItems;
     }


    // Called after the page is loaded. It adds a context menu to each node,
    // therefore the nodes must be created.
    function CreateContextMenus(){
        console.log("CreateContextMenus");

        // Goes to the right URL given the selected key of a contextual menu.
        function FromKeyToScript(key, options)
        {
            // We will merge the new content with the existing content or not.
            var menuOptions = {};
            $.contextMenu.getInputValues(options, menuOptions);
            // This applies to the two types of contextual menu: Per node or general.
            globalMustMerge = menuOptions.yesno;

            // This is a Python script, but not a contextual menu displayed by "entity.py".
            var theUrl = key + "&mode=json";
            console.log("theUrl="+theUrl);
            LoadUrlUpdateDisplay(theUrl, RefillDisplay,globalMustMerge);
        }


        $.contextMenu(
        {
            selector: 'g.survol_node',

            build: function($trigger, evt) {
                // This callback is executed every time the menu is to be shown
                // Its results are destroyed every time the menu is hidden
                // evt is the original contextmenu event, containing evt.pageX and evt.pageY (amongst other data)

                // In JSON format, the node on which we have right-clicked.
                var objectSvg = $trigger["0"]["__data__"];

                var theItems = MakeContextMenuItems(objectSvg);

                return {
                    // This is executed when an option is chosen in a contextual menu.
                    callback: function(key, options)
                    {
                        if(key == "delete_node")
                        {
                            // TODO: Have a specific callback.
                            DeleteSvgNode(objectSvg);
                        }
                        else if(key == "delete_connected")
                        {
                            DeleteSvgConnectedNodes(objectSvg);
                        }
                        else
                        {
                            FromKeyToScript(key, options);
                        }
                    },
                    items: theItems
                };
            }
        });

        var dfltItms = MakeDefaultContextMenuItems();

        /* There is one default menu, loaded once and for all,
        and it does not use the "promise" feature of the library.
        Therefore it is built asynchronously. */

        // Adds a context menu for the background.
        function AddsDefaultCtxtMenu(dfltItms)
        {
            console.log("AddsDefaultCtxtMenu");
            $.contextMenu(
            {
                selector: 'svg',
                build: function($trigger, evt) {

                    dfltItms["yesno"] = {
                        name: "Merge graphs",
                        type: 'checkbox',
                        selected: false
                    };

                    return {
                        callback: function(key, options)
                        {
                            FromKeyToScript(key, options);
                        },
                        items: dfltItms
                    };
                }
            });
        } // AddsDefaultCtxtMenu

        // This returns the top-level options.
        // var urlTopLevel = "htbin/entity.py?mode=menu";
        var urlTopLevel = "htbin/entity_dirmenu_only.py?mode=menu";

        d3.json(urlTopLevel, AddsDefaultCtxtMenu);
    }; // CreateContextMenus


    // When the mouse right button is down, this loads the contextual menu content into the SVG object.
    // When this right button is released, it triggers the contextual menu which finds its content
    // stored in the SVG object.
    $("g.survol_node").mousedown(function(ev){
        /* Si clicke gauche, on va vers le "entity.py". */

        function GetEntityUrl(jsonData)
        {
            // Maybe this duplicates the value. Not a problem.
            objectThis.__data__.contextual_menu_items = jsonData;

            objectThis.__data__.dfd.resolve(jsonData);
        }

        if(ev.which == 3)
        {
            var objectThis = this;

            // We expect a contextual menu in JSON format, not a graph.
            // TODO: Have a script which returns only the menu tree in json, without the intermediate
            // step of RDF encoding.
            var urlEntity = this.__data__.survol_url.replace("entity.py","entity_dirmenu_only.py") + "&mode=menu";
            console.log("URL:"+urlEntity);

            this.__data__.dfd = jQuery.Deferred();

            d3.json(urlEntity, GetEntityUrl);
        }
    });

    // Call function after page load: http://stackoverflow.com/questions/890090/jquery-call-function-after-load
    // $(CreateContextMenus);
    CreateContextMenus();
} // DisplayD3Layout

/*
    function LoadUrlsList()
    {
        prms = resetParams();
    }

    // Related to a change in history ?
    //window.addEventListener && window.addEventListener('popstate', BuildUrlsList);

    BuildUrlsList();

    console.log("params="+JSON.stringify(BuildUrlsList));
    // return function(BuildUrlsList) { return params.hasOwnProperty(BuildUrlsList) ? BuildUrlsList[param] : null; }
    return BuildUrlsList;
}; // GetCgiParams
*/

// At startup.
var theurl = "htbin/sources_types/enumerate_CIM_Process.py?xid=.&mode=json";
// var theurl = "htbin/sources_types/CIM_Process/process_cwd.py?xid=CIM_Process.Handle%3D2976&mode=json";
// var theurl = "htbin/sources_types/enumerate_CIM_LogicalDisk.py?xid=.&mode=json";

function UrlRelativeToAbsolute(href) {
    'use strict';
    var link = document.createElement("a");
    link.href = href;
    return (link.protocol+"//"+link.host+link.pathname+link.search+link.hash);
}

function PreloadUrls(theInputUrls)
{
    'use strict';
    console.log("theInputUrls="+JSON.stringify(theInputUrls));

    var isCreated = false;

    for( var idx in theInputUrls )
    {
        var cgiPair = theInputUrls[idx];
        console.log("cgiPair="+JSON.stringify(cgiPair));
        if( cgiPair.cgi_key == "url" )
        {
            var aUrlB64 = cgiPair.cgi_value;
            var aUrlRel = Base64.decode(aUrlB64);

            var aUrlNoMode = UrlRelativeToAbsolute(aUrlRel)

            // This reasonably expects that there is at least one CGI argument.
            var aUrlMode = aUrlNoMode + "&mode=json";
            console.log("aUrlNoMode="+aUrlNoMode);

            if(isCreated)
            {
                // Merge all URLs together.
                LoadUrlUpdateDisplay(aUrlMode, RefillDisplay,true);
            }
            else
            {
                LoadUrlUpdateDisplay(aUrlMode, CreateDisplay,false);
                isCreated = true;
            }
        }
    }

    // If not URL on the command line.
    if( ! isCreated )
    {
        LoadUrlUpdateDisplay(theurl, CreateDisplay,false);
    }
}

function RunAfterLoad()
{
    // "getParamValue=[{"cgi_key":"toto","cgi_value":"tutu"},{"cgi_key":"titi","cgi_value":"tata"}]"
    var theInputUrls = GetCgiParams();
    PreloadUrls(theInputUrls);
}

// Call function after page load: http://stackoverflow.com/questions/890090/jquery-call-function-after-load
$(RunAfterLoad);


/*
http://bl.ocks.org/GerHobbelt/3669455
Rester dans la partie visible : Voir la fonction.
RDF doit passer la contrainte sur les propriétés: Ajouter des triplets RDF qui expriment le layout hierarchique:
« Layout »  property  « valeur »
Mais il n est pas certain que ca suffise quand on a beaucoup d’objets.
*/


function TstMerge()
{
    var tstInputUrls =
    [
        {
            cgi_key : "url",
            cgi_value : "http://127.0.0.1:8000/htbin/sources_types/CIM_DataFile/file_stat.py?xid=CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29"
        },
        {
            cgi_key : "url",
            cgi_value : "http://127.0.0.1:8000/htbin/entity.py?xid=rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
        }
    ];
    PreloadUrls(tstInputUrls);
}

/*
https://stackoverflow.com/questions/36841013/custom-force-directed-symbols-in-d3-tables-as-nodes
SVG has a group element that you can use to organize what can be an arbitrarily complex node.
Also, you don't have to use an SVG. You can use D3 to manipulate say, the absolute positioning of HTML table elements.


*/

</script>


<body>
Test D3
<a href="xxxx_merge.py">Printable view (Static SVG)</a><br/>



<a href="#" onClick="">Test Merge</a>
<!-- We could put these data in a special pop-up, or a drop-down list.
- Add a summary at the end.
- Add a tick box for each line, to hide or delete.
- Display classes of nodes, on the X axis (optionnaly)
-->
<table id="UrlsList"></table>

</body>
</html>
