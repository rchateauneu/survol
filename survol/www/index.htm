<!DOCTYPE html>
<meta charset="utf-8">

<html>
<head>

    <title>Survol</title>

<!--  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js" -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<xxscript src="js/jquery.min.js"></xxscript>


<!-- Port to D3 v4 could be done by a specialist. -->

    <!-- src="http://d3js.org/d3.v3.min.js" -->
<script src="http://d3js.org/d3.v3.min.js"></script>
<xxscript src="js/d3.v3.min.js"></xxscript>
<script src="js/base64.js"></script>
<script src="js/revjslib.js"></script>

    <!-- href="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.css" -->
<link href="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.css" rel="stylesheet" type="text/css" />
<xxlink href="js/jquery.contextMenu.css" rel="stylesheet" type="text/css" />

    <!--  src="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.js" -->
<script src="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.js" type="text/javascript"></script>
<xxscript src="js/jquery.contextMenu.js" type="text/javascript"></xxscript>

<script src="js/ActiveX_WMI.js"></script>

<script type="text/javascript">
// Ca marche mais on en n'a pas besoin.
//window.onerror = function (errorMsg, url, lineNumber) {
//    alert('Error: ' + errorMsg + ' Script: ' + url + ' Line: ' + lineNumber);
//}
</script>

<style>

    .survol_line {
        stroke: #111111;
        // stroke-width: 1px; // Ca marche.
        stroke-width: 1;
        // stroke-dasharray: 4, 1; // Ca marche.
    }

    // For some links. CA NE MARCHE PAS.
    .ppid {
        stroke: #111111;
        stroke-width: 5px;
        stroke-dasharray: 4, 1;
    }

    // Ca marche.
    .nodetext {
        pointer-events: none;
        font: 10px sans-serif;
    }

    /* Probably not be used now as far as I can tell ... */
    .link1 {
        stroke: #000;
        stroke-width: 3px;
    }

    .nodetext {
        pointer-events: none;
        font: 10px sans-serif;
    }

    /* Probably not used.
    https://css-tricks.com/multiple-class-id-selectors/
    This selects all elements with the class name type1 that are descendents of the element with a class of node.
    */
    .node.type1 {
        fill:brown;
    }
    .node.type2 {
        fill:#337147;
    }
    .node.type3 {
        fill:blue;
    }
    .node.type4 {
        fill:red;
    }
    .node.type5 {
        fill:#1BC9E0;
    }
    .node.type6 {
        fill:#E01B98;
    }

    // https://css-tricks.com/multiple-class-id-selectors/
    // This selects all elements with the class name CIM_ComputerSystem that are descendents of the element with a class of node.
    .CIM_ComputerSystem {
        fill:#E01B98;
        font: 12px sans-serif;
        background: lightsteelblue;
        // opacity: 0.5;
        border: 8px;
    }

    .CIM_LogicalDisk {
        // fill:#1BC9E0; // Ca marche
        font: 20px sans-serif;
        background: lightsteelblue;
        // opacity: 0.5;
        border: 8px;
    }

    .CIM_Process {
        // fill:#E01B98; // Ca marche
        font: 12px sans-serif;
        background: lightsteelblue;
        /* opacity: 0.9; // Ca marche */
        border: 8px;
        // rx: 10; // Ca marche pas.
        // ry: 10;
    }

    /* Probably not used. */
    image.circle {
        cursor:pointer;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%; /* aspect ratio */
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content-responsive {
        display: inline-block;
        position: absolute;
        top: 10px;
        left: 0;
    }

    /* This is for the tooltips. if no "width" and "height", it resizes automatically. */
    div.tooltip {
        position: absolute;
        text-align: center;
        /*
        width: 100px;
        height: 40px;
        */
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }

</style>

<script>
/*
TODO:
- Undo edition.
- Mixer les SVG avec des graphes et des trees.
  Ou bien lier les nodes de facon rigide, matricielle. On les mettrait dans une classe specifique.
- A terme, pour les couleurs, ne pas utiliser le JSON mais charger le fichier CSS dans le directory de la classe.
- Afficher quelque chose quand le result "json" est vide.
- Afficher la meme chose en Graphviz: Pour ce faire, on pourrait injecter le reseau, en JSON dans un script
Python qui le retransformerait en RDF etc...
L'avantage est qu on peut tout afficher. En revanche, on perd la possibilite d'actualiser
une requete particulierement interessante. Notons qu en pratique, les requetes combinees ne sont pas encore
specifiees et seront surement tres differentes.

We wish to pass several parameters so that scripts and objects can be added or substracted,
with pattern matching possibilities.
Should we pass the arguments as GET or as a JSON document ?
This could assume the CGI structure:
"http://127.0.0.1:8000/survol.htm?xid=CIM_Directory.Name=E%3A%2FHewlett-Packard%2FSystemDiags"

What about "+"/"-" ??

xxx.htm?xid=(XID1)&script=(SCRIPT1)&operator=+&xid=(XID2)&script=(SCRIPT2)

By default the operator is "+".

And also we need to restore merge_rdf_inputs_graphviz_only.htm,
in fact it can handle all modes, something like merger.py.
Its role is to produce a document based on several URLs.
And we will zap the files *merge*.htm .
Also, we must transmit to graphic properties for edges: This simply means having a specific object:
"COLLAPSED_PROPERTY" property "True"
... ou bien:
"PROPERTY_LAYOUT" property "Ortho"

*/

/*
http://127.0.0.1:8000/survol/sources_types/CIM_DataFile/file_stat.py?xid=CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29
http://127.0.0.1:8000/survol/entity.py?xid=rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672

// The URLs list is something like that. It is not needed to split the xid.
[
    script="sources_types/CIM_DataFile/file_stat.py",
    xid:"CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29"
],
[
    script="entity.py"
    xid="rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],


ou tout simplement:
[
    urls:"sources_types/CIM_DataFile/file_stat.py?CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29",
    url:"entity.py?rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],

Ou meme:
[
    urls:"http://127.0.0.1:8000/sources_types/CIM_DataFile/file_stat.py?CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29",
    url:"http://127.0.0.1:8000/entity.py?rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],

A terme:
- En theorie, un URL peut etre utilise sur plusieurs machines et donner le meme resultat si on ajoute le host.
Donc on pourrait executer le meme script sur plusieurs machines. Ou suivre le meme objet sur plusieurs machines.
Et donc on reecrirait l'URL.
- On peut vouloir executer tous les scripts relatifs a un objet (On liste tous les scripts).
*/
function GetCgiParams()
{
    // console.log("resetParams");
    var query = window.location.search;
    var regex = /[?&;](.+?)=([^&;]+)/g;
    var match;

    var params = [];

    if (query) {
        while (match = regex.exec(query))
        {
            // There might be "=" equal signs in the value of the CGI variable.
            // "http://127.0.0.1:8000/survol/sources_types/CIM_Directory/file_directory.py?xid=CIM_Directory.Name=E%3A%2FHewlett-Packard%2FSystemDiags"
            cgiObj = { cgi_key: match[1], cgi_value: decodeURIComponent(match[2])};

            params.push(cgiObj);
        }
    }
    return params;
}; // GetCgiParams


var wScreen;
var hScreen;
var myForce = null;

var divSvg = null;

// This stores the current nodes and links. Maybe there is a simpler way to store them.
var previousData = null;

var divTooltip = null;

// https://stackoverflow.com/questions/41705135/how-to-disable-mouseover-and-mouseout-event-while-dragging-with-d3
var isDragging = false;

// Sanity check to ensure that nodes and links are properly matched.
function CheckGraph(theNam,theData)
{
    'use strict';
    ///////////////////// return;
    if(theData == null)
    {
        return;
    }
    console.log(theNam+" nodes="+theData.nodes.length+" links="+theData.links.length);

    console.log("=================");
    for( var ix = 0; ix < theData.nodes.length; ix++ )
    {
        objNod = theData.nodes[ix]
        // console.log("CheckGraph ix="+ix+" "+JSON.stringify(objNod));
    }
    // console.log("=================");

    for( var ix = 0; ix < theData.links.length; ix++ )
    {
        if( theData.links[ix].source == undefined )
        {
            console.log(theNam+" Undefined source ix="+ix);
        }
        if( theData.links[ix].source >= theData.nodes.length )
        {
            console.log(theNam+" Too big source ix="+ix+" :"+theData.links[ix].source);
        }
        if( theData.links[ix].target == undefined )
        {
            console.log("Undefined target ix="+ix);
        }
        if( theData.links[ix].target >= theData.nodes.length )
        {
            console.log(theNam+" Too big target ix="+ix+" :"+theData.links[ix].target);
        }

        // console.log("Check ix="+ix+" source="+theData.links[ix].source+" target="+theData.links[ix].target);
    }
    console.log("===============");
} // CheckGraph



function D3DisplayCreation()
{
    'use strict';

    function MyZoom() {
        divSvg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    }

    var win = window,
        doc = document,
        elt = doc.documentElement,
        geb = doc.getElementsByTagName('body')[0];

    // First defined and non-zero values.
    wScreen = win.innerWidth || elt.clientWidth || geb.clientWidth,
    hScreen = win.innerHeight|| elt.clientHeight|| geb.clientHeight;

    // http://stackoverflow.com/questions/16265123/resize-svg-when-window-is-resized-in-d3-js
    // This allows the resizing.
    divSvg = d3.select("body")
        .append("div")
        .classed("svg-container", true) //container class to make it responsive
        .append("svg:svg")
        //responsive SVG needs these 2 attributes and no width and height attr
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", "0 0 " + wScreen + " " + hScreen)

        // style="border-style:solid;border-width:1px;"
        .attr("style","border-style:solid;border-width:1px;")

        //class to make it responsive
        .classed("svg-content-responsive", true)
        // SVG Geometric Zooming https://bl.ocks.org/mbostock/3680999
        .call(d3.behavior.zoom().scaleExtent([0.125, 8]).on("zoom", MyZoom))
        ;

    myForce = d3.layout.force();
} // D3DisplayCreation

// Mais pourquoi data est passe en premier ? au lieu de (error,data ) ?
// Ah peut-etre d2 version 3 au lieu de 4 ?
function CreateDisplay(data)
{
    if( data == null )
    {
        alert("CreateDisplay: Json data is null");
        return;
    }

    // CheckGraph("new",data);
    D3DisplayCreation();

    // Brand new graph, no need to merge.
    previousData = data;
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
} // CreateDisplay

/* Called when adding a new url and merge it to the existing nodes and links. */
function RefillDisplayMerge(data, currTimeStamp)
{
    // This creates a new list of nodes with new numbers and without the duplicates.
    // The links also, are recreated, with new numbers.
    var previousNodes = previousData.nodes;
    var prevUrlsToIds = {};

    var lenPrevNodes = previousNodes.length;
    var maxAlerts = 3;
    for (var ixNod = 0; ixNod < lenPrevNodes; ixNod++) {
        var urlNode = previousNodes[ixNod].survol_url;
        // console.log("RefillDisplay(1) urlNode="+urlNode);

        // Sanity check:
        if(prevUrlsToIds[urlNode] != undefined)
        {
            // Not too many alerts.
            if(maxAlerts > 0)
            {
                alert("ixNod="+ixNod+" prevUrlsToIds[urlNode] undefined. urlNode="+urlNode);
                maxAlerts--;
            }
        }

        // Normally, at this stage, each URL should appear only once.
        prevUrlsToIds[urlNode] = ixNod;
    }

    // console.log("prevUrlsToIds elements:"+JSON.stringify(prevUrlsToIds));

    // The new numbers of the new nodes are written in the nodes themselves.
    var newNodes = data.nodes;
    var lenNewNodes = newNodes.length;
    for( var ixNod = 0; ixNod < lenNewNodes; ixNod++ )
    {
        var newNod = newNodes[ixNod];
        var urlNode = newNod.survol_url;
        console.log("RefillDisplay(2) urlNode="+urlNode);

        // Sanity check
        if( urlNode == undefined)
        {
            alert("urlNode undefined. ixNod="+ixNod);
        }

        // Index of the same URL in the current list of nodes.
        var oldIdx = prevUrlsToIds[urlNode];

        if( oldIdx == undefined )
        {
            // Most common case of a new node.
            var idxAppend = previousNodes.length;
            newNod.new_index = idxAppend;
            // The timestamp must already be set.
            if( newNod.survol_timestamp == undefined ) {
                alert("Inconsistent timestamp (1)");
                return;
            }
            // newNod.survol_timestamp = currTimeStamp;

            // Sanity check
            if( idxAppend < lenPrevNodes )
            {
                alert("idxAppend="+idxAppend);
            }

            // The new node is copied at the end.
            previousNodes.push(newNod);
        }
        else
        {
            // The node already exists, no copy, but this merge the input scripts lists.
            newNod.new_index = oldIdx;

            if( previousNodes[oldIdx].survol_input_scripts == undefined )
            {
                alert("Previous node should have input scripts");
                return;
            }

            if( newNod.survol_input_scripts == undefined )
            {
                alert("New node should have input scripts");
                return;
            }

            previousNodes[oldIdx].survol_input_scripts
                = previousNodes[oldIdx].survol_input_scripts.concat(newNod.survol_input_scripts)

            previousNodes[oldIdx].survol_timestamp = currTimeStamp;

            // Sanity check
            if( previousNodes[oldIdx].survol_url != urlNode)
            {
                alert("Inconsistent urls oldIdx="+oldIdx);
            }
        }
    }

    // Now we renumber the edges.
    var newLinks = data.links;
    var lenNewLinks = newLinks.length;
    var previousLinks = previousData.links;
    for( var ixLnk = 0; ixLnk < lenNewLinks; ixLnk++ )
    {
        var newLnk = newLinks[ixLnk];

        var idxSourceMapped = newNodes[newLnk.source].new_index;

        // Sanity check
        if(idxSourceMapped == undefined)
        {
            alert("Source undefined newLnk.source="+newLnk.source);
        }

        newLnk.source = idxSourceMapped;

        var idxTargetMapped = newNodes[newLnk.target].new_index;

        // Sanity check
        if(idxTargetMapped == undefined)
        {
            alert("Target undefined newLnk.target="+newLnk.target);
        }

        // console.log("Rewire "+ixLnk+" target from "+newLnk.target+" to "+idxTargetMapped);
        newLnk.target = idxTargetMapped;

        // Sanity check
        if(newLnk.source == undefined)
        {
            alert("newLnk.source undefined. ixLnk="+ixLnk);
        }
        if(newLnk.target == undefined)
        {
            alert("newLnk.target undefined. ixLnk="+ixLnk);
        }

        // If the source and the targets had to be remapped,
        // it means that the target was already there.
        // However, we insert it again because it should be rare,
        // and the duplicated edge might bring more information.
        previousLinks.push(newLnk);
    }

    // Now a last pass to remove the duplicate nodes.
    var ixNod = 0;
    while(ixNod < lenNewNodes)
    {
        var newNod = newNodes[ixNod];

        // Sanity check
        if(newNod.new_index == undefined)
        {
            alert("newNod.new_index undefined ixNod="+ixNod);
        }

        if(newNod.new_index < lenPrevNodes)
        {
            // The node already exists.
            newNod.new_index = oldIdx;
            newNodes.splice(ixNod,1); // Beware, this might be slow.
            console.log("Removing duplicate ixNod="+ixNod);
            lenNewNodes--;
        }
        else
        {
            ixNod++;
        }
    }

    // Sanity check
    if(lenNewNodes != data.nodes.length)
    {
        alert("Inconsistency lenNewNodes="+lenNewNodes+" data.nodes.length="+data.nodes.length);
    }

    // Sanity check.
    CheckGraph("prev",previousData);
} // RefillDisplayMerge

/* Called when reloading the content of a script which was previously loaded. */
function RefillDisplayRefresh(theUrl,data,currTimeStamp)
{
    var urlNoJson = UrlWithoutJsonMode( theUrl );
    console.log("RefillDisplayRefresh urlNoJson="+urlNoJson+" currTimeStamp="+currTimeStamp);

    if( currTimeStamp == undefined ) {
        alert("Inconsistent timestamp (4)");
        return;
    }


    /* Merge the new content with the old, but the all nodes from the new data set,
    are tagged with a time-stamp. */
    RefillDisplayMerge(data,currTimeStamp);

    CheckGraph("refresh1",previousData);

    /* Delete from the merged grph, the nodes from the same URL but which were not time-stamped,
    which means they did not reappear in the new content of the same URL.
    If they come from several URLs, maybe keep them if one of the other URLs is automatically refreshed
    and has any precedence.
    TODO: IMPLEMENT THIS. For the moment, simplified version. */

    console.log("RefillDisplayRefresh previousData.nodes.length="+previousData.nodes.length);
    for (var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ ) {
        var objNode = previousData.nodes[ixNod];

        console.log("RefillDisplayRefresh ixNod="+ixNod+" survol_input_scripts="+objNod.survol_input_scripts+" timestamp="+objNode.survol_timestamp);
        idxIn = objNod.survol_input_scripts.indexOf(urlNoJson);

        console.log("idxIn="+idxIn);
        if ( idxIn >= 0 )
        {
            console.log("Comparing timestamps");
            if( objNode.survol_timestamp == undefined ) {
                alert("Inconsistent timestamp (2)");
                return;
            }
            if( objNode.survol_timestamp > currTimeStamp ) {
                alert("Inconsistent timestamp (3)");
                return;
            }

            /* This node was not in the new content of the same URL. */
            if( objNode.survol_timestamp < currTimeStamp )
            {
                /* The node does not appear in the new content of the same URL,
                so it must be deleted. */

                // Ensuite refaire le merge si ActiveX.


                console.log("DELETING ixNod="+ixNod);

                // continue; // TEMP TEMP

                /// DeleteD3NodeFromIndex(ixNod);

                previousData.nodes.splice(ixNod,1);

                // At this stage the new nodes still contain an index.
                for( var ixLnk = 0; ixLnk < previousData.links.length; ixLnk++ )
                {
                    objLnk = previousData.links[ixLnk];
                    if( ( objLnk.source == ixNod ) || ( objLnk.target == ixNod ) )
                    {
                        previousData.links.splice(ixLnk,1);
                        ixLnk--;
                        continue;
                    }
                    if(objLnk.source > ixNod) {
                        objLnk.source--;
                    }
                    if(objLnk.target > ixNod) {
                        objLnk.target--;
                    }
                }

                CheckGraph("refresh2 "+ixNod,previousData);
                // Because it will be incremented.
                ixNod--;
            }
        }
    }
    CheckGraph("refresh2",previousData);
} // RefillDisplayRefresh

// Callback of contextual menu. It receives the JSON menu sent by the server.
function RefillDisplay(theUrl,data,shouldMerge,currTimeStamp)
{
    'use strict';
	console.log("RefillDisplay entering shouldMerge="+shouldMerge+" currTimeStamp="+currTimeStamp);
    CheckGraph("new",data);
    if( data == null )
    {
        alert("RefillDisplay: Json data is null");
        return;
    }

    // UTC timestamp in milliseconds.
    // var currTimeStamp = Date.now();
    // newNod.survol_timestamp = currTimeStamp

    if( (previousData == null ) || (shouldMerge == false) )
    {
        previousData = data;
    }
    else
    {
        // If the url is already loaded, rather call RefillDisplayRefresh.
        if( shouldMerge == MergeRefreshMode )
        {
            RefillDisplayRefresh(theUrl,data,currTimeStamp);
        }
        else if( shouldMerge == true )
        {
            // If we merge the current nodes and links with the new one.
            RefillDisplayMerge(data,currTimeStamp);
        }
        else
        {
            alert("RefillDisplay Cannot do anything theUrl="+theUrl);
            return;
        }
    }

	console.log("RefillDisplay before EmptyDisplay");

    EmptyDisplay();

	console.log("RefillDisplay before DisplayD3Layout");


	/*
	Probleme dans previousData
	TypeError: r.target is undefined
	*/

    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
    // globalMustMerge = false;
	console.log("RefillDisplay leaving");
} // RefillDisplay

function EmptyDisplay()
{
    'use strict';
    var node = divSvg.selectAll("g.survol_node")
        .data([])
        .exit()
        .remove();

    var link = divSvg.selectAll(".survol_line")
        .data([])
        .exit()
        .remove();

    // previousData = null;
} // EmptyDisplay

/* When deleting a node from the contextual menu. Deletes the nodes and its links. */
function FindIndexFromNode(objectSvg)
{
    'use strict';
    // No need of a lookup because it happens just once.
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        var goodNodeIdx;
        if( previousData.nodes[ixNod].survol_url == objectSvg.survol_url )
        {
            goodNodeIdx = ixNod;
            console.log("FindIndexFromNode found ixNod="+ixNod);
            return goodNodeIdx;
        }
    }

    alert("Could not find url="+objectSvg.survol_url);
    return -1;
} // FindIndexFromNode

function DeleteD3NodeFromIndex(goodNodeIdx)
{
    console.log("DeleteD3NodeFromIndex goodNodeIdx="+goodNodeIdx);
    var goodNode = previousData.nodes[goodNodeIdx];

    // The node is removed and the following node numbers are decremented.
    // Therefore the links must be updated.
    previousData.nodes.splice(goodNodeIdx,1);

    // The link is pointing to the node to be deleted. Each index is replaced by the node itself
    // NOTE: APPARENTLY THE NODE INDICES ARE REPLACED BY THE NODE OBJECT.
    previousData.links = previousData.links.filter(
        function(objLnk) {
            return (objLnk.source != goodNode ) && ( objLnk.target != goodNode );
        });
    console.log("DeleteD3NodeFromIndex previousData.links.length="+previousData.links.length);
}

/* When deleting a node from the contextual menu. Deletes the nodes and its links. */
function DeleteSvgNode(objectSvg)
{
    'use strict';
    var goodNodeIdx = FindIndexFromNode(objectSvg);

    DeleteD3NodeFromIndex(goodNodeIdx);

    EmptyDisplay();
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
    console.log("DeleteSvgNode reset globalMustMerge");
    globalMustMerge = false;
} // DeleteSvgNode

function MarkToDel(flag)
{
    'use strict';
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        previousData.nodes[ixNod].to_delete = flag;
    }
    for( var ixLnk = 0; ixLnk < previousData.links.length; ixLnk++ )
    {
        previousData.links[ixLnk].to_delete = flag;
    }
} // MarkToDel

// There is no direct way to get the edges connected to one node,
// so this recursively explores the graph and marks objects for deletion.
function DeleteSvgConnectedNodes(objectSvg)
{
    'use strict';

    MarkToDel(false);

    // First, builds for each node, the list of edges starting from it.
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        previousData.nodes[ixNod].indices_links_list = [];
    }

    // Now target and source point to node object, not indices.
    for( var ixLnk = 0; ixLnk < previousData.links.length; ixLnk++ )
    {
        var objLnk = previousData.links[ixLnk];

        // In this context, the links are bidirectionnal.
        objLnk.source.indices_links_list.push(ixLnk);
        objLnk.target.indices_links_list.push(ixLnk);
    }

    // Recursively marked connected nodes for deletion.
    function RecursAppendConnected(objNod)
    {
        var lstIdxEdges = objNod.indices_links_list;
        objNod.to_delete = true;
        for( var ixEdgeKey in lstIdxEdges )
        {
            var ixEdgeIdx = lstIdxEdges[ixEdgeKey];
            var objLnk = previousData.links[ixEdgeIdx];
            var nodOther = null;
            if( objLnk.target == objNod )
                nodOther = objLnk.source;
            else if( objLnk.source == objNod )
                nodOther = objLnk.target;
            else alert("We have a problem");
            if( nodOther.to_delete == false )
            {
                RecursAppendConnected(nodOther);
            }
        }
    } // RecursAppendConnected

    var goodNodeIdx = FindIndexFromNode(objectSvg);
    var goodNode = previousData.nodes[goodNodeIdx];

    RecursAppendConnected(goodNode);

    // Now we just need to delete.
    // TODO: It may be simpler if indexing with URLs.

    previousData.nodes = previousData.nodes.filter( function(objNod) { return ! objNod.to_delete; });

    previousData.links = previousData.links.filter( function(objLnk) {
        return ! ( objLnk.source.to_delete || objLnk.target.to_delete );
    });

    // Same code as for deleting one node.
    EmptyDisplay();
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
    console.log("DeleteSvgConnectedNodes reset globalMustMerge");
    globalMustMerge = false;
} // DeleteSvgConnectedNodes

////////////////////////////////////////////////////////////////////////////////

// The list of currently loaded urls.
// TODO: This is also the UNDO list,
// and therefore will contain "pseudo-urls" meaning that such or such object
// was added or removed.
var lstLoadedUrls = [];

// We do not add methods because the object must be cloned when sent as a message.
function lstLoadedUrls_DeleteAll()
{
    for( var idxUrl = 0; idxUrl < lstLoadedUrls.length; idxUrl++ )
    {
        lstLoadedUrls_DeleteOne(0);
    }
}

// Deletes an URL in the list and cancels the timer if needed.
function lstLoadedUrls_DeleteOne(idxUrl)
{
    lstLoadedUrls_TimerSet(idxUrl);
    lstLoadedUrls.splice(idxUrl,1);
}

var MergeRefreshMode = 2;

// When the url is deleted, the timer must also be cleared.
function TimerRefreshUrl(objLoadedUrl)
{
    console.log("TimerRefreshUrl m_loaded_url="+objLoadedUrl.m_loaded_url);

    urlJson = AppendCgiToUrl(objLoadedUrl.m_loaded_url,"mode=json");

    // TODO: Finish this !!
    LoadUrlUpdateDisplay(urlJson, MergeRefreshMode );
}

function lstLoadedUrls_TimerSet(idxUrl,newRate)
{
    console.log("TimerSet idxUrl="+idxUrl+" newRate="+newRate);
    lstLoadedUrls[idxUrl].m_refresh_rate = newRate;
    if( lstLoadedUrls[idxUrl].m_timer_refresh != undefined )
    {
        clearInterval(lstLoadedUrls[idxUrl].m_timer_refresh);
    }
    if((newRate != undefined) && (newRate != 0))
    {
        // TEMP TEMP TEMP TEMP TEMP TEMP TEMP TEMP TEMP TEMP TEMP TEMP TEMP
        lstLoadedUrls[idxUrl].m_timer_refresh = setInterval( TimerRefreshUrl, newRate * 60 * 1000, lstLoadedUrls[idxUrl] );
        // lstLoadedUrls[idxUrl].m_timer_refresh = setInterval( TimerRefreshUrl, newRate * 5 * 1000, lstLoadedUrls[idxUrl] );
    }
} // lstLoadedUrls_TimerSet

// This tells if an URL is already loaded.
function IsLoadedUrl(theUrl)
{
    var urlNoJson = UrlWithoutJsonMode( theUrl );
    for( var idxUrl = 0; idxUrl < lstLoadedUrls.length; idxUrl++ )
    {
        console.log("IsLoadedUrl idxUrl="+idxUrl+" url="+lstLoadedUrls[idxUrl].m_loaded_url);
        if( urlNoJson == lstLoadedUrls[idxUrl].m_loaded_url ) {
            console.log("IsLoadedUrl urlNoJson="+urlNoJson+" already there");
            return true;
        }
    }
    console.log("IsLoadedUrl urlNoJson="+urlNoJson+" not loaded");
    return false;
} // IsLoadedUrl



////////////////////////////////////////////////////////////////////////////////
/* This is called when clicking "Del" on the Summary little window. */
function ProcessSummaryWindowDel(idxUrl)
{
    objLoadedUrl = lstLoadedUrls[idxUrl];
    // The URL can be something like "survol/sources_types/enumerate_CIM_Process.py?xid=."
    // It should be identical to what is stored in the nodes.
    objUrlStr = objLoadedUrl.m_loaded_url;
    // console.log("ProcessSummaryWindowDel DelScript:"+objUrlStr);

    for( var ixNd = 0; ixNd < previousData.nodes.length; ixNd++ )
    {
        objNod = previousData.nodes[ixNd];
        // console.log("ixNd="+ixNd+" node="+JSON.stringify(objNod));

        // If the node was created by this script.
        idxIn = objNod.survol_input_scripts.indexOf(objUrlStr);
        // console.log("idxIn="+idxIn);
        if ( idxIn >= 0 )
        {
            // If the node was created only by this script, the delete it.
            if( objNod.survol_input_scripts.length == 1 ) {
                DeleteD3NodeFromIndex(ixNd);
                ixNd--; // One node less.
            } else {
                // Otherwise just remove the URL.
                objNod.survol_input_scripts.splice( idxIn, 1 );
            }
        }
    } // Loop on nodes.

    lstLoadedUrls_DeleteOne(idxUrl);

    // Maybe we could refresh the display at each node ?
    EmptyDisplay();
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);

    RefreshSummaryWindow();
} // ProcessSummaryWindowDel

/* Messages received from the Summary window are made of a vector: The first element is a string
which indicates the type of operation. */
function ProcessSummaryWindowMessages(event)
{
    // event={"isTrusted":false}
    // "DelScript:0"
    var msgSent = event.data;
    // "http://192.168.1.83"
    var msgOrig = event.origin;
    var keyWord = msgSent[0];
    console.log("msgSent="+msgSent+" msgOrig="+msgOrig+" event="+JSON.stringify(event));

    if(keyWord == 'ChangeRate')
    {
        var idxUrl = msgSent[1];
        var newRate = msgSent[2];
        console.log("newRate="+newRate+" idxUrl="+idxUrl);

        lstLoadedUrls_TimerSet(idxUrl,newRate);
    } else if(keyWord == 'DelScript')
    {
        idxUrl = msgSent[1];
        ProcessSummaryWindowDel(idxUrl);
    } // If delete nodes exclusive from a script.

} // ProcessSummaryWindowMessages

console.log("Initializing windowObjectReference");

// Declare it but with an invalid value.
var windowObjectReference = null;

/* This is called when a URL is loaded. It updates the little Summary window
by sending as a message the list of loaded urls. */
function RefreshSummaryWindow()
{
    if(windowObjectReference) {
        console.log("RefreshSummaryWindow: Sending message to summary window lstLoadedUrls.length="+lstLoadedUrls.length);
        lstLoadedUrls.number_nodes = previousData.nodes.length;
        lstLoadedUrls.number_links = previousData.links.length;

        windowObjectReference.postMessage(lstLoadedUrls,"*");
    } else {
        console.log("RefreshSummaryWindow: Summary window not created");
    }
    return;
} // RefreshSummaryWindow

/* Add the origin URL to each node. This is used for example to selectively delete nodes
coming from a specific URL, or to refresh the result of an URL. Note that URL and scripts
have the same meaning in this file: Python scripts returning JSON data and invoked as HTTP URLs. */
function NodeSetInputScript(urlObj,theData)
{
    // UTC timestamp in milliseconds.
    var currTimeStamp = Date.now();

    // Maybe could use a regular expression.
    var urlObjRaw = UrlWithoutJsonMode( urlObj );
    console.log("NodeSetInputScript urlObj="+urlObj+" NumNodes="+theData.nodes.length);
    // Loop on the nodes and add the url.
    for( var ix = 0; ix < theData.nodes.length; ix++ )
    {
        objNod = theData.nodes[ix];

        // We know that the object is freshly loaded, so we can create a new list.
        objNod.survol_input_scripts = [urlObjRaw];

        objNod.survol_timestamp = currTimeStamp;
    }

    return currTimeStamp;
} // NodeSetInputScript

/* Each node remembers the script which created it.
The "options" parameter comes from contextMenu which passes it to the callback. */
function RememberCallback(options, urlObj, data)
{
    console.log("RememberCallback urlObj="+urlObj+" NumNodes="+data.nodes.length);
    var currTimeStamp = NodeSetInputScript(urlObj,data)

    var menuOptions = {};
    $.contextMenu.getInputValues(options, menuOptions);
    // This applies to the two types of contextual menu: Per node or general.
    shouldMerge = menuOptions.yesno;

    // Now process the new nodes. Duplicate nodes will have two sources or more.
    RefillDisplay(urlObj, data, shouldMerge, currTimeStamp );
}


/* Loads from a URL, a JSON document made of nodes and links.
After that, updates a table containing the list of loaded URLs. */
function LoadUrlUpdateDisplay(theUrl,shouldMerge)
{
    'use strict';

    if( shouldMerge == false ) {
        // Each element must be properly destroyed.
        lstLoadedUrls_DeleteAll();
    }

    // This is called by a JSON document loaded from a Python script.
    function LoaderCallback(data)
    {
        console.log("LoaderCallback theUrl="+theUrl);
        if( data == null )
        {
            console.log("LoaderCallback: data is null");
            return;
        }
        if( data.survol_error != undefined )
        {
            alert("Error:"+data.survol_error);
            return;
        }

        // This merges the new data with the current one.
        // Each node remembers the script which created it.
        var currTimeStamp = NodeSetInputScript(theUrl,data);

        var actualMergeMode = shouldMerge;
        if( IsLoadedUrl(theUrl) ) {
            actualMergeMode = MergeRefreshMode;
        }

        RefillDisplay(theUrl,data, actualMergeMode, currTimeStamp);

        // If refresh, do not change the list of loaded urls.
        var urlNoJson = UrlWithoutJsonMode( theUrl )
        if( actualMergeMode != MergeRefreshMode )
        {
            var objLoadedUrlNew = {
                m_loaded_url : urlNoJson,
                m_loaded_title : data.page_title,
                m_loaded_nodes_length : data.nodes.length,
                m_loaded_links_length : data.links.length
                };
            lstLoadedUrls.push(objLoadedUrlNew);
        }
        else
        {
            var objUrl;
            for( var ixUrl = 0; ixUrl < lstLoadedUrls.length; ++ixUrl )
            {
                objUrl = lstLoadedUrls[ixUrl];
                if( objUrl.m_loaded_url == urlNoJson )
                {
                    console.log("Updating url ixUrl="+ixUrl);
                    objUrl.m_loaded_nodes_length = data.nodes.length;
                    objUrl.m_loaded_links_length = data.links.length;
                    break;
                }
            }
            if( objUrl == undefined )
            {
                alert("Cannot find url ixUrl="+ixUrl);
                return;
            }
        }

        RefreshSummaryWindow();
    } // LoaderCallback


    /* TODO: If theUrl="http://127.0.0.1:8000/survol/merge_scripts.py?url=aHRiaW4vc...",
    then parse the URLs, and load each of them. */
    console.log("LoadUrlUpdateDisplay theUrl="+theUrl);

    if(isDragging) {
        console.log("NoUrl loading when dragging");
        return;
    }

    // Removes immediately tooltip if it is here.
    if(divTooltip) {
        divTooltip.style("opacity", 0);
    }

	try
	{
		d3.json(theUrl, LoaderCallback );
	}
	catch(exc)
	{
		console.log("LoadUrlUpdateDisplay caught:"+exc);
		var emptyData = {
			nodes: [],
			links: []
		};
		LoaderCallback(emptyData);
	}
} // LoadUrlUpdateDisplay

function AppendCgiToUrl(url,cgipair)
{
	console.log("AppendCgiToUrl url="+url);
	if( url.indexOf("?") < 0 )
		return url + "?" + cgipair;
	else
		return url + "&" + cgipair;
}

function UrlWithoutJsonMode(theUrl)
{
    return theUrl.replace("?mode=json","").replace("&mode=json","")
}

function DisplayD3Layout(divSvg,newData,w,h)
{
    'use strict';
    console.log("DisplayD3Layout newData.nodes="+newData.nodes.length+" newData.links="+newData.links.length);

    function tick_function()
    {
        /* Apply the constraints: On verra plus tard.
        using layout.force to plot tree graphs (where nodes may have multiple parents) - Part 1: pure tree
        http://bl.ocks.org/GerHobbelt/3669455
        */

        link.attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });

        // http://mbostock.github.io/d3/talk/20110921/bounding.html
        selectedNodes.attr("transform", function (d) {
            /*
            // Ca fonctionne mais ca n'est pas tres beau.
            var rr = 10;
            d.x = Math.max(rr, Math.min(w - rr, d.x));
            d.y = Math.max(rr, Math.min(h - rr, d.y));
            */

            return "translate(" + d.x + "," + d.y + ")";
        });
    }

	// console.log("newData.nodes"+JSON.stringify(newData.nodes));
	// console.log("newData.links"+JSON.stringify(newData.links));
	
    // It is possible to link nodes by names in D3 v4: https://bl.ocks.org/mbostock/533daf20348023dfdd76
    myForce
        .nodes(newData.nodes)
        .links(newData.links)
        .distance(100)
        .charge(-1000)
        .linkDistance(100)
        .size([wScreen, hScreen])
        .on("tick", tick_function)
        .start();

    var link = divSvg.selectAll(".survol_line")
        .data(newData.links)
        .enter().append("svg:line")
        .attr("class", function (d) { return "link" + d.value + " survol_line"; }) // "link10"
        .attr("x1", function (d) { return d.source.x; })
        .attr("y1", function (d) { return d.source.y; })
        .attr("x2", function (d) { return d.target.x; })
        .attr("y2", function (d) { return d.target.y; })
        // "Error in parsing value for "markedr-end": This is why I removed this.
        // .attr("marker-end", function (d) { if (d.value == 1) { return "url(#arrowhead)"; } else { return " "; }; })
        // .append("svg:title").text(function(d) { return d.link_prop; })
        ;

    // Creates one SVG object (Which class ?) for each survol node.
    // CA DEVRAIT ALLER POUR AJOUTER DES NODES.
    var selectedNodes = divSvg.selectAll("g.node")
        .data(newData.nodes)
        .enter().append("svg:g")
        .attr("class", function (d)
            {
                return "survol_node node " + d.entity_class;
            }
        ) // Several classes are possible.
        .call(myForce.drag);

	/* https://stackoverflow.com/questions/30723592/prevent-click-action-when-dragging-a-d3-node
	When combining drag with other event listeners,
	stop propagation on the source event to prevent multiple actions.
	Otherwise, dragging also triggers the click behavior when the mouse is released. */

    // var d3BehDrag = d3.behavior.drag();
    var d3BehDrag = myForce.drag();
    d3BehDrag
        .on("dragstart", function() {
            isDragging = true; // This avoids the tooltip when dragging.
            // Tooltip ne fonctionne plus !!!
            console.log("Tooltip disabled");
        })
        .on("dragend", function() {
            d3.event.sourceEvent.stopPropagation(); // silence other listeners
            isDragging = false; // Tooltip when hovering is now allowed.
            console.log("Tooltip enabled");
        })
        ;

    // fill:#337147;

    // Define the div for the tooltip.
    // If set globally, it is null here.
    divTooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0.5)
        ;

    // Used for the tooltip containg literal nodes pointing to a given node, i.e. information.
    // TODO: This should be recursive.
    function DictToTable(theList,theDict)
    {
        var result = "<table>"
        for (var ix in theList) {
            result += "<tr><td valign='top' align='left' colspan='2'><b>" + theList[ix] + "</td></tr>";
        }
        for (var key in theDict) {
            if (theDict.hasOwnProperty(key)) {
                result += "<tr><td valign='top' align='left'><b>" + key + "</b></td><td valign='top' align='left'>" + theDict[key] + "</td></tr>";
            }
        }
        result += "</table>";
        return result;
    } // DictToTable

    // https://bl.ocks.org/mbostock/7555321 Wrapping Long Labels
    function addTextLines(selection) {
        selection.each(function(d) {
            var theText = d3.select(this)
            theText.text(null).append("tspan").attr("x", 0).text(d.name);
            var cntLine = 0;

            for (var ix in d.survol_info_list) {
                theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(d.survol_info_list[ix]);
            }

            for (var key in d.survol_info_dict) {
                if (d.survol_info_dict.hasOwnProperty(key)) {
                    var txtKeyVal = key + "=" + d.survol_info_dict[key];
                    theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(txtKeyVal);
                }
            }

            // info_list
            // theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(d.name);
        })
    } // addTextLines

    function getTextBox(selection) {
        selection.each(function(d) { d.bbox = this.getBBox(); })
    }

    // This is the text associated to each survol node.
    selectedNodes.append("svg:text")
        // .attr("class", "nodetext " + d.entity_class) // Ca marche pas.
        .attr("class", "nodetext")
        .attr("dx", 0)
        .attr("dy", ".35em")
        .attr("text-anchor", "middle")
        // .text(function (d) { return d.name; }) // Use tspan and tref ???
        // .text(function (d) { return '<tspan>' + d.name + '</tspan><tspan dy="10">First line.</tspan>'; }) // Use tspan and tref ???
        .call(addTextLines)
        .call(getTextBox)
    ;

    // Adds text inside each "g" object of class "survol_node": http://stackoverflow.com/questions/6725288/svg-text-inside-rect
    // Inserts the rect element before the text, which is therefore not hidden.
    d3.selectAll(".survol_node").insert("rect","text")
        .attr("x", function(d){return d.bbox.x})
        .attr("y", function(d){return d.bbox.y})

        // Ces attributs vont refleter un calcul car on peut toujours les appliquer.
        // Bizarrement, pas moyen d'overrider rx et ry avec CSS.
        .attr("rx", 5) // Pas moyen d'overrider ca avec CSS
        .attr("ry", 5)
        .attr("opacity", 1)

        .attr("width", function(d){return d.bbox.width})
        .attr("height", function(d){return d.bbox.height})
        .style("stroke-width", 1)
        .style("stroke", "#000000")
        // Classes are not defined so fill colors are OK. We will fetch CSS in classes directories.
        .attr("fill", function (d) {
            /* #337147 */
            return d.survol_fill;
        })
        .attr("class", function (d) { return d.entity_class; })
        //.attr("class", function (d) { return "node type" + d.survol_type; })
        .on("mouseover", function(d)
            {
                // No tooltip creation when dragging because it is very CPU-consuming.
                if(isDragging) {
                    console.log("No tooltip when dragging");
                    return;
                }
                d.is_mouseover = true;

                // Loading a URL is very heavy. Maybe we should wait some tenths of seconds to check
                // if we are still on this node, before loading the tooltip.
                function IfMouseOver(d,currentEventD3pageX,currentEventD3pageY)
                {
                    if( false == d.is_mouseover ) {
                        console.log("MouseOver too late");
                        return;
                        }
                    if( isDragging ) {
                        console.log("IfMouseOver not when dragging");
                        return;
                        }

					// This object probably comes from WMI only.
					// TODO: We could still have a URL and rather check if a server is here ??
					if( ! d.survol_url ) {
                        console.log("No script data without URL");
                        return;
                        }
						
                    // d.survol_info_dict is a dictionary, and survol_info_list is a list.
                    // These two members are filled when parsing the input JSON document.
                    var urlReplaced = d.survol_url.replace("entity.py","entity_info_only.py");
                    var urlTooltip = AppendCgiToUrl(urlReplaced,"mode=json");

                    // "urlTooltip=http://127.0.0.1:8000/survol/entity_info_only.py?xid=rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51759 -&gt; 127.0.0.1:5672&mode=json"

                    console.log("Loading urlTooltip="+urlTooltip);

                    d3.json(urlTooltip,
                        function(objTooltip)
                        {
                            console.log("Callback urlTooltip="+urlTooltip+ " objTooltip="+JSON.stringify(objTooltip));
                            if( objTooltip.survol_error != undefined )
                            {
                                alert("Error:"+objTooltip.survol_error);
                                return;
                            }
                            if( false == d.is_mouseover ) {
                                console.log("After tooltip loaded: too late");
                                return;
                                }

                            if( isDragging ) {
                                console.log("No tooltip when dragging");
                                return;
                                }

                            if( objTooltip == null ) return ;
                            if( typeof(objTooltip.nodes) == 'undefined' ) return ;
                            if( typeof(objTooltip.nodes[0]) == 'undefined' ) return ;

                            // THIS MUST BE REPLACED BECAUSE UGLY AND NOT FLEXIBLE.
                            var objInfo = objTooltip.nodes[0].survol_info_dict
                            if ( typeof(objInfo) != 'undefined')
                            {
                                var txtTooltip = DictToTable([],objInfo);
                                console.log("txtTooltip="+txtTooltip);

                                // http://stackoverflow.com/questions/36326683/d3-js-how-can-i-set-the-cursor-to-hand-when-mouseover-these-elements-on-svg-co
                                // This could as well be done in CSS, but we might wish not change the pointer if no link is available, i.e. faulty node.
                                d3.select(this).style("cursor", "pointer");

                                divTooltip.transition()
                                    .duration(200)
                                    .style("opacity", .9);

                                divTooltip.html( txtTooltip )
                                    .style("left", (currentEventD3pageX) + "px")
                                    .style("top", (currentEventD3pageY - 28) + "px");
                            }
                        }
                    );
				} // IfMouseOver

                var currentEventD3 = d3.event;

                // Tooltip starts only after 500 milliseconds.
				setTimeout( function() { IfMouseOver(d,currentEventD3.pageX,currentEventD3.pageY); } , 500 );
            }
        )
        .on("mouseout", function(d)
            {
                // console.log("Resetting MouseOver");
                d.is_mouseover = false;

                // This could as well be done in CSS.
                d3.select(this).style("cursor", "default");

                divTooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }
        )
        .on("click", function(d)
            {
                // TODO: Disabled for the moment because we do not know how to
                // make it work with drag. Consider double-click ??
                // This option is not mandatory because it is still possible to right-click.
                console.log("CLICK is disabled");
                return;

                // Removes immediately tooltip if it is here.
                // divTooltip.style("opacity", 0);

                // This expects a graph, not a contextual menu.
                var aUrl = AppendCgiToUrl( d.survol_url, "mode=json");
                console.log("aUrl="+aUrl);
                LoadUrlUpdateDisplay(aUrl, false);
            })
        ;

    var radius = d3.scale.log().domain([0, 312000]).range(["10", "50"]);

    // Is that to avoid collisions ? Is the drag needed here ?
    d3.selectAll(".circle").append("circle")
        .attr("class", function (d) { return "node type" + d.survol_type; })
        // TODO: No change when it is commented out.
        //.attr("r", function (d) { return radius(d.value) || 10; })
        .call(myForce.drag);

    // This returns the contextual menu for nodes.
    function MakeContextMenuItems(objectSvg)
    {
        // SHOULD CALL entity_info_only.py BUT THE PROBLEM IS THAT IT IS NOT THE ORIGINAL NODE
        // SO THERE IS A CONFUSION WITH entity.py THAT EVERYTHING RELIES ON.
        // ALSO, WHEN mode=json WE SHOULD NOT DISPLAY THE WBEM AND WMI LINKS AND THE SCRIPTS.
        // MAYBE A ANOTHER MODE NEEDED FOR JUST TEXT INFORMATION FOR THE TOOLTIP.
        // BUT THIS IS VERY HEAVY TO CALL THIS EACH TIME WE HOVER OVER A NODE.
        var objUrl = objectSvg.survol_url;
        console.log("objUrl="+objUrl);

        var objKey = objectSvg.name;

        var objDeferScripts = objectSvg.defer_scripts;
        console.log("MakeContextMenuItems objKey="+objKey);

        /* Peut-etre ajouter des URLs specifiques pour WMI et OpenWBEM ce qui justifierait qu'on aie
        des scripts Python specifiques.
        */

        var TheItems = {};

        // This is the title, and it is clickable.
        TheItems[ objUrl ] =
        {
            name: objKey
        };

        // If CIM_DataFile, this creates a MIME link on the fly.
        function urlCIM_DataFileToMime(url)
        {
            if(url.indexOf("survol/entity.py?xid=CIM_DataFile.") < 0)
                return null;
            return url.replace("survol/entity.py","survol/file_to_mime.py");
        }

        var urlMime = urlCIM_DataFileToMime(objUrl);
        if(urlMime) {
			TheItems[urlMime] = {
                    "name": "Mime Display",
                    "icon": "paste"
			};
        }

        // Not needed if this is an external URL.
        if( objUrl.indexOf("survol/") >= 0 ) {
            // By default, results of scripts is merged with the current graph.
            var TheItemsSuite =
            {
                "yesno": {
                    name: "Merge graphs",
                    type: 'checkbox',
                    selected: true
                },
                "name": {
                    name: "Parameters (In progress...)",
                    type: 'text',
                    value: "Hello World",
                    events: {
                        keyup: function(e) {
                            // add some fancy key handling here?
                            window.console && console.log('key: '+ e.keyCode);
                        }
                    }
                }
            };
            jQuery.extend(TheItems, TheItemsSuite);
        }

		// Maybe there are Python scripts for this object.
		if(objDeferScripts) {
			// https://swisnl.github.io/jQuery-contextMenu/demo/async-promise.html Submenu through promise.
			var menusSurvol = objDeferScripts.promise();

			var TheItemsScripts = {
				"sep1": "---------",
				"SurvolMenu": {
					name: "Scripts...",
					items: menusSurvol,
				}
			};
			jQuery.extend(TheItems, TheItemsScripts);
		}

		// objectSvg contains the original object created from the WMI command.
		// But it might also simply contain the attribute taken from the URL ?
		// Or we should parse the URL and add the properties into it (and the class),
		// so we could query from WMI with just our properties ??
		// Problem with Base64 ? But why not detecting on the fly if a string is Base64-encoded ??
		// PROBLEM: We have lost the class used from the query. This is not:
		// "CreationClassName, "CSCreationClassname", "OSCreationClassName".
		// Or is it in "entity_class" ?
		// TODO: Should add it.
		if(objUrl) {
			console.log("Calling ActiveX_WMI_JContextMenu objUrl="+objUrl);

			// This creates a clickable item which calls RefillDisplay with the associators objects
			// transformed into a JSON graph.

			var TheItemsSuiteActiveX = ActiveX_WMI_JContextMenu(objUrl,objectSvg, RememberCallback );

			// console.log("Called ActiveX_WMI_JContextMenu objUrl="+objUrl);
			if( TheItemsSuiteActiveX != [] )
			{
				jQuery.extend(TheItems, TheItemsSuiteActiveX);
			}
		}

        var TheItemsSuiteDels =
        {
            "delete_node": {
                "name": "Delete node",
                "icon": "delete"
            },
            "delete_connected": {
                "name": "Delete connected nodes",
                "icon": "delete"
            }
        };
        jQuery.extend(TheItems, TheItemsSuiteDels);

        return TheItems;
    } // MakeContextMenuItems

    /* This returns the contextual menu for the background.
    It is immediately superseded, and the sample data are here just for documentation. */
    function MakeDefaultContextMenuItems(objectSvg)
    {
        var theDfltItems =
        {
            "xxxx": {
                name: "xxxx",
                type: 'checkbox',
                selected: false
            },
            "yyyy": {
                "name": "yyyyy",
                "items": {
                    "edit": {"name": "Edit", "icon": "edit"},
                    "cut": {"name": "Cut", "icon": "cut", disabled: true},
                    "quit": {"name": "Quit", "icon": "quit"}
                }
            }
        };
        return theDfltItems;
     } // MakeDefaultContextMenuItems


    /* Called after the page is loaded. It adds a context menu to each node,
    therefore the nodes must be created. A lot of information here:
    https://github.layalk.net/jQuery-contextMenu/docs.html */
    function CreateContextMenus(){
        console.log("CreateContextMenus");

        // Goes to the right URL given the selected key of a contextual menu.
        function FromKeyToScript(key, options)
        {
            // We will merge the new content with the existing content or not.
            var menuOptions = {};
            $.contextMenu.getInputValues(options, menuOptions);
            // This applies to the two types of contextual menu: Per node or general.

            // This is a Python script, but not a contextual menu displayed by "entity.py".
            var theUrl = AppendCgiToUrl( key, "mode=json");
            console.log("FromKeyToScript theUrl="+theUrl);
            LoadUrlUpdateDisplay(theUrl, menuOptions.yesno );
        }

        // For an URL which returns HTML and to be opened in its own window.
        // Similar to ScriptForJson in Python.
        function PlainNonEntityUrl(url)
        {
            if( url.indexOf("survol/file_to_mime.py") >= 0 )
            {
                return true;
            }
            if( url.indexOf("survol/") >= 0 )
            {
                return false;
            }
            // This is a foreign URL
            return true;
        } // PlainNonEntityUrl

        $.contextMenu(
        {
            selector: 'g.survol_node',

            build: function($trigger, evt) {
                // This callback is executed every time the menu is to be shown
                // Its results are destroyed every time the menu is hidden
                // evt is the original contextmenu event, containing evt.pageX and evt.pageY (amongst other data)

                // In JSON format, the node on which we have right-clicked.
                var objectSvg = $trigger["0"]["__data__"];

                var theItems = MakeContextMenuItems(objectSvg);

                return {
                    // This is executed when an option is chosen in a contextual menu.
                    callback: function(key, options)
                    {
                        if(key == "delete_node")
                        {
                            // TODO: Have a specific callback.
                            DeleteSvgNode(objectSvg);
                        }
                        else if(key == "delete_connected")
                        {
                            DeleteSvgConnectedNodes(objectSvg);
                        }
                        else
                        {
                            if( PlainNonEntityUrl(key) )
                            {
                                window.open(key, '_blank','location=no,height=570,width=520,scrollbars=yes,status=yes');
                                return;
                            }
                            FromKeyToScript(key, options);
                        }
                    },
                    items: theItems
                };
            }
        });

        var dfltItms = MakeDefaultContextMenuItems();

        /* There is one default menu, loaded once and for all,
        and it does not use the "promise" feature of the library.
        Therefore it is built asynchronously. */

        // Adds a context menu for the background.
        function AddsDefaultCtxtMenu(dfltItms)
        {
            console.log("AddsDefaultCtxtMenu entering");
            if( dfltItms.survol_error != undefined )
            {
                alert("Error:"+dfltItms.survol_error);
                return;
            }
            $.contextMenu(
            {
                selector: 'svg',
                build: function($trigger, evt) {
					// This does not need the Python HTTP server.
					console.log("ActiveX_WMI_JCtxtMenuGlobal before");

					var activeXDefaultMenus = ActiveX_WMI_JCtxtMenuGlobal( RememberCallback );

					console.log("ActiveX_WMI_JCtxtMenuGlobal after");
					if( activeXDefaultMenus )
					{
					    console.log("activeXDefaultMenus="+JSON.stringify(activeXDefaultMenus));
        				dfltItms["sep2"] = "---------";

						dfltItms["wmiglobal"] = {
							name: "WMI Globals",
							"items" : activeXDefaultMenus
						};
					}

                    // This adds an extra item to the menu returned by a Python script.
                    dfltItms["yesno"] = {
                        name: "Merge graphs",
                        type: 'checkbox',
                        selected: false
                    };

                    return {
                        callback: function(key, options)
                        {
                            console.log("callback key="+key);
                            FromKeyToScript(key, options);
                        },
                        items: dfltItms
                    };
                }
            });
            console.log("AddsDefaultCtxtMenu leaving");
        } // AddsDefaultCtxtMenu

        // This returns the top-level options as a JSON tree.
        var urlTopLevel = url_survol_prefix + "entity_dirmenu_only.py?mode=menu";

		try {
			d3.json(urlTopLevel, AddsDefaultCtxtMenu);
		}
		catch(exc)
		{
			console.log("CreateContextMenus caught:"+exc);
			var emptyItems = {
				"Nothing" : {
                        name: "Empty menu",
                        type: 'text'
                    }
				};

			AddsDefaultCtxtMenu(emptyItems);
		}
    }; // CreateContextMenus


    // When the mouse right button is down, this loads the contextual menu content into the SVG object.
    // When this right button is released, it triggers the contextual menu which finds its content
    // stored in the SVG object.
    $("g.survol_node").mousedown(function(ev){
        /* Si clicke gauche, on va vers le "entity.py". */

        function GetEntityUrl(jsonData)
        {
            if( jsonData.error != undefined )
            {
                alert("Error:"+jsonData.error);
                return;
            }
            // Maybe this duplicates the value. Not a problem.
            objectThis.__data__.contextual_menu_items = jsonData;

            objectThis.__data__.defer_scripts.resolve(jsonData);
        }

        if(ev.which == 3)
        {
            var objectThis = this;

			// If this was defined from a Python script.
			if(this.__data__.survol_url) {
				console.log("Right click on URL="+this.__data__.survol_url);
				if(this.__data__.survol_url.indexOf("entity.py") < 0) {
				    /*
				    Very special case of the execution of file_directory.py : It returns CIM_DataFile and
				    CIM_Directory, but also links to file_directory.py with the entity type CIM_Directory.
				    So these nodes become also clickable.
				    */
				    console.log("Should not happen: only entity.py is clickable");
				    return;
				}
				// We expect a contextual menu in JSON format, not a graph.
				// TODO: Have a script which returns only the menu tree in json, without the intermediate
				// step of RDF encoding.
				var urlEntity = this.__data__.survol_url.replace("entity.py","entity_dirmenu_only.py") + "&mode=menu";
				console.log("URL:"+urlEntity);

				this.__data__.defer_scripts = jQuery.Deferred();

				// This loads the menu options as a JSON tree.
				d3.json(urlEntity, GetEntityUrl);
			}
        }
    });

    // Call function after page load: http://stackoverflow.com/questions/890090/jquery-call-function-after-load
    // $(CreateContextMenus);
    CreateContextMenus();
} // DisplayD3Layout


// At startup.
var urlInit = url_survol_prefix + "sources_types/enumerate_CIM_Process.py?xid=.&mode=json";

/* The calling URL might as well be:
http://192.168.1.88/Survol/survol/entity.py?xid=smbshr.Id=////WDMyCloudMirror/rchateau
http://127.0.0.1:8000/survol/sources_types/CIM_Directory/file_directory.py?xid=file.Id%3DC%3A\windows\system32
*/

function BuildSubUrlsListFromCgi(cgiArgs)
{
    'use strict';
    var splitCgiArgs = cgiArgs.split("&");
    var arrUrls = [];

    for(var kvpIdx in splitCgiArgs)
    {
        var kvp = splitCgiArgs[kvpIdx];
        var splitKVP = kvp.split("=");
        if( splitKVP.length == 2)
        {
            if(splitKVP[0] == "url")
            {
                arrUrls.push(splitKVP[1]);
            }
        }
    }
    return arrUrls;
} // BuildSubUrlsListFromCgi

function BuildSubUrlsListFromJson(theInputUrls)
{
    'use strict';
    var arrUrls = [];

    for( var idx in theInputUrls )
    {
        var cgiPair = theInputUrls[idx];
        if( cgiPair.cgi_key == "url" )
        {
            arrUrls.push(cgiPair.cgi_value);
        }
    }
    return arrUrls;
} // BuildSubUrlsListFromJson

var globalIsCreated = false;

function PreloadUrlsArray(urlsArray)
{
    'use strict';

    D3DisplayCreation();

    var numUrls = 0;
    for( var idx in urlsArray )
    {
        var aUrlB64 = urlsArray[idx];
        var aUrlRel = Base64.decode(aUrlB64);

        var idxScriptStart = aUrlRel.indexOf(pyMergeScript);
        console.log("PreloadUrlsArray idx="+idx+" idxScriptStart="+idxScriptStart+" globalIsCreated="+globalIsCreated+" aUrlRel="+aUrlRel);
        if( idxScriptStart != -1 ) {
            var idxScriptEnd = idxScriptStart + pyMergeScript.length;
            var cgiArgs = aUrlRel.substring( idxScriptEnd + 1 );

            var arrUrls = BuildSubUrlsListFromCgi(cgiArgs);
            PreloadUrlsArray(arrUrls);

            numUrls += arrUrls.length;
        } else {

            var aUrlNoMode = aUrlRel;

            // This reasonably expects that there is at least one CGI argument.
            var aUrlMode = AppendCgiToUrl( aUrlNoMode, "mode=json");

            LoadUrlUpdateDisplay(aUrlMode, true );
            numUrls += 1;
        }
    }

    // If not URL on the command line.
    if( numUrls == 0 )
    {
        console.log("No URL to preload");
        LoadUrlUpdateDisplay(urlInit, false);
    }
    return numUrls;
} // PreloadUrlsArray

/* This opens the summary list in a separate window.
It displays the URL which were loaded, how to delete them, how many nodes and links etc... */
function openRequestedPopup() {
    // So the summary window can send messages which are executed in the main window.
    // TODO: Should do it once only.
    window.addEventListener("message", ProcessSummaryWindowMessages, false);

    if( (windowObjectReference == null) || (windowObjectReference.closed))
    {
        console.log("openRequestedPopup creating windowObjectReference");
        windowObjectReference = window.open(
            "summary.htm", // this.href,
            'targetWindow',
            'toolbar=no,location=no,status=no,menubar=no,scrollbars=yes,resizable=yes,directories=no,width=550,height=300'
        );

        // There is a sort of race condition: The summary window id sometimes gets blanked after it is filled.
        windowObjectReference.onload = function() {
            // alert("After create");
            RefreshSummaryWindow();
        };

    } else {
        console.log("openRequestedPopup windowObjectReference created");
    }

    windowObjectReference.focus();

    // RefreshSummaryWindow();
}

function RunAfterLoad()
{
    // "getParamValue=[{"cgi_key":"toto","cgi_value":"tutu"},{"cgi_key":"titi","cgi_value":"tata"}]"
    var theInputUrls = GetCgiParams();

    var urlsArray = BuildSubUrlsListFromJson(theInputUrls);

    globalIsCreated = false;
    var numUrls = PreloadUrlsArray(urlsArray);

	console.log("RunAfterLoad finished")

	$(IdHrefSummary).on("click", openRequestedPopup);

	window.name = gblWindowName;
} // RunAfterLoad

// Call function after page load: http://stackoverflow.com/questions/890090/jquery-call-function-after-load
$(RunAfterLoad);


/*
http://bl.ocks.org/GerHobbelt/3669455
Rester dans la partie visible : Voir la fonction.
RDF doit passer la contrainte sur les proprits: Ajouter des triplets RDF qui expriment le layout hierarchique:
 Layout   property   valeur 
Mais il n est pas certain que ca suffise quand on a beaucoup dobjets.
*/


/*
https://stackoverflow.com/questions/36841013/custom-force-directed-symbols-in-d3-tables-as-nodes
SVG has a group element that you can use to organize what can be an arbitrarily complex node.
Also, you don't have to use an SVG. You can use D3 to manipulate say, the absolute positioning of HTML table elements.
Ajouter le lien de merge.
*/

</script>

</head>




<table border="0" width="100%"><tr>
    <td>Survol. <i>Understanding legacy applications. Based on WMI/WBEM, with a Web interface. &copy; Primhill Computers 2017</i></td>
    <td align="right"><a href="#" id="IdHrefSummary">Summary</a>&nbsp;
<a href="../entity.py">Print layout</a>&nbsp;
<a href="help.htm">Help</a>
<a href="configuration.htm">Configuration</a>
        <a href="index_technical.htm">Test links</a>
    </td>
</tr></table>

</body>
</html>
