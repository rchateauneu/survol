<!DOCTYPE html>
<html>

<head>

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta charset="UTF-8">
<meta name="theme-color" content="#ffffff">


<!--  src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js" -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>


<!-- Port to D3 v4 could be done by a specialist. -->

    <!-- src="http://d3js.org/d3.v3.min.js" -->
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="js/base64.js"></script>
<script src="js/revjslib.js"></script>

    <!-- href="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.css" -->
<link href="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.css" rel="stylesheet" type="text/css" />

    <!--  src="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.js" -->
<script src="https://swisnl.github.io/jQuery-contextMenu/dist/jquery.contextMenu.js" type="text/javascript"></script>

<script src="js/ActiveX_WMI.js"></script>

<link rel='stylesheet' type='text/css' href=css/html_exports.css>

<script type="text/javascript">
// This works but not needed yet.
//window.onerror = function (errorMsg, url, lineNumber) {
//    alert('Error: ' + errorMsg + ' Script: ' + url + ' Line: ' + lineNumber);
//}
</script>

<style>

    .survol_line {
        stroke: #111111;
        /* stroke-width: 1px; */ /* This works. */
        stroke-width: 1;
        /* stroke-dasharray: 4, 1; */ /* This works. */
    }

    /* For some links. IT DOES NOT WORK. */
    .ppid {
        stroke: #111111;
        stroke-width: 5px;
        stroke-dasharray: 4, 1;
    }

    /* This works.*/
    .nodetext {
        pointer-events: none;
        font: 10px sans-serif;
    }

    /* Probably not be used now as far as I can tell ... */
    .link1 {
        stroke: #000;
        stroke-width: 3px;
    }

    .nodetext {
        pointer-events: none;
        font: 10px sans-serif;
    }

    .CIM_ComputerSystem {
        /* fill:#E01B98; */
        font: 12px sans-serif;
        background: lightsteelblue;
        /* opacity: 0.5; */
        border: 8px;
    }

    .CIM_LogicalDisk {
        /* fill:#1BC9E0; */ /* This works. */
        font: 20px sans-serif;
        background: lightsteelblue;
        /* opacity: 0.5; */
        border: 8px;
    }

    .CIM_Process {
        /* fill:#E01B98; */ /* This works. */
        font: 12px sans-serif;
        background: lightsteelblue;
        /* opacity: 0.9; */ /* This works. */
        border: 8px;
        /* rx: 10; */ /* This works. */
        /* ry: 10; */
    }

    /* Probably not used. */
    image.circle {
        cursor:pointer;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 100%; /* aspect ratio */
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content-responsive {
        display: inline-block;
        position: absolute;
        top: 10px;
        left: 0;
    }

    /* This is for the tooltips. if no "width" and "height", it resizes automatically. */
    div.tooltip {
        position: absolute;
        text-align: center;
        /*
        width: 100px;
        height: 40px;
        */
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
    }

</style>

<script>
/*
TODO:
- Undo edition.
- Mix SVG nodes with graphes and trees.
  Maybe they could be linked in a matrix ?
- For colors, use CSS.
- When a Json document is empty, should display a message.

We wish to pass several parameters so that scripts and objects can be added or substracted,
with pattern matching possibilities.
Should we pass the arguments as GET or as a JSON document ?
This could assume the CGI structure:
"http://127.0.0.1:8000/survol.htm?xid=CIM_Directory.Name=E%3A%2FHewlett-Packard%2FSystemDiags"

What about "+"/"-" ??

xxx.htm?xid=(XID1)&script=(SCRIPT1)&operator=+&xid=(XID2)&script=(SCRIPT2)

By default the operator is "+".

And also we need to restore merge_rdf_inputs_graphviz_only.htm,
in fact it can handle all modes, something like merger.py.
Its role is to produce a document based on several URLs.
And we will zap the files *merge*.htm .
Also, we must transmit to graphic properties for edges: This simply means having a specific object:
"COLLAPSED_PROPERTY" property "True"
... ou bien:
"PROPERTY_LAYOUT" property "Ortho"

*/

/*
http://127.0.0.1:8000/survol/sources_types/CIM_DataFile/file_stat.py?xid=CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29
http://127.0.0.1:8000/survol/entity.py?xid=rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672

// The URLs list is something like that. It is not needed to split the xid.
[
    script="sources_types/CIM_DataFile/file_stat.py",
    xid:"CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29"
],
[
    script="entity.py"
    xid="rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],


or simply:
[
    urls:"sources_types/CIM_DataFile/file_stat.py?CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29",
    url:"entity.py?rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],

Or even:
[
    urls:"http://127.0.0.1:8000/sources_types/CIM_DataFile/file_stat.py?CIM_DataFile.Name%3DC%3A\Program%20Files%20%28x86%29",
    url:"http://127.0.0.1:8000/entity.py?rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51533%20-%3E%20127.0.0.1:5672"
],

A URL could be used on several agents, returning the same result if the agent is provided in the URL.
*/
function GetCgiParams()
{
    // console.log("resetParams");
    var query = window.location.search;
    var regex = /[?&;](.+?)=([^&;]+)/g;
    var match;

    var params = [];

    if (query) {
        while (match = regex.exec(query))
        {
            // There might be "=" equal signs in the value of the CGI variable.
            // "http://127.0.0.1:8000/survol/sources_types/CIM_Directory/file_directory.py?xid=CIM_Directory.Name=E%3A%2FHewlett-Packard%2FSystemDiags"
            cgiObj = { cgi_key: match[1], cgi_value: decodeURIComponent(match[2])};

            params.push(cgiObj);
        }
    }
    return params;
}; // GetCgiParams


var wScreen;
var hScreen;
var myForce = null;

var divSvg = null;

// This stores the current nodes and links. Maybe there is a simpler way to store them.
var previousData = null;

// Contains the current tooltip.
var divTooltip = null;

// https://stackoverflow.com/questions/41705135/how-to-disable-mouseover-and-mouseout-event-while-dragging-with-d3
var isDragging = false;

// Sanity check to ensure that nodes and links are properly matched.
// This is slow but useful in development mode.
function CheckGraph(theNam,theData)
{
    'use strict';

    // Add comments when in production version.
    ///////////////////// return;
    if(theData == null)
    {
        return;
    }
    console.log(theNam+" nodes="+theData.nodes.length+" links="+theData.links.length);

    console.log("=================");
    for( var ix = 0; ix < theData.nodes.length; ix++ )
    {
        objNod = theData.nodes[ix]
        // console.log("CheckGraph ix="+ix+" "+JSON.stringify(objNod));
    }
    // console.log("=================");

    for( var ix = 0; ix < theData.links.length; ix++ )
    {
        if( theData.links[ix].source == undefined )
        {
            console.log(theNam+" Undefined source ix="+ix);
        }
        if( theData.links[ix].source >= theData.nodes.length )
        {
            console.log(theNam+" Too big source ix="+ix+" :"+theData.links[ix].source);
        }
        if( theData.links[ix].target == undefined )
        {
            console.log("Undefined target ix="+ix);
        }
        if( theData.links[ix].target >= theData.nodes.length )
        {
            console.log(theNam+" Too big target ix="+ix+" :"+theData.links[ix].target);
        }

        // console.log("Check ix="+ix+" source="+theData.links[ix].source+" target="+theData.links[ix].target);
    }
    console.log("===============");
} // CheckGraph


/*
Where does the URL come from ? The URL can independently come from several sources:
- Python script URLs from SVG print layout. Just need to reformat them on the fly.
- Python script URLs listed in the summary window. Just reformat them on the fly.
- Vairous URLs from other systems: do the necessary conversion and creation of nodes:
  HTTP or FTP urls etc... Of course WBEM urls from Yawn or elsewhere ?
- We must find a way to display Json URLs, from D3 display.
  Maybe they could be just the title of the node.
  Possibly, there would be a onClick, which might do nothing, but still it would be
  an Url and as such, draggable and dropable. Given that D3 already uses drag-and-drop,
  which is not easy to change, and possibly incompatible between v3 and v4.
  Do that later.
*/
function onDrop(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    var droppedUrl = evt.dataTransfer.getData("URL");

    console.log("onDrop droppedUrl="+droppedUrl);

    var adaptedUrl = null;

    /* The URL can be a Python script:
    http://127.0.0.1:8000/survol/sources_types/odbc/table/odbc_table_columns.py?xid=odbc/table.Dsn%3DDSN~MyNativeSqlServerDataSrc%2CTable%3DCOLUMN_DOMAIN_USAGE
    This detection is not very reliable, but the only bad consequence is loading badly-formatted Json data.
    */
    ixSourcesTypes = droppedUrl.indexOf("/sources_types/");
    if(ixSourcesTypes >= 0) {
        adaptedUrl = AppendCgiToUrl(droppedUrl,"mode=json");
    }

    if(adaptedUrl) {
        /* If the URL has the right style, it is added. This always merges. */
        /*
        Nodes from various hostnames must have something specifically visible,
        when it is different from the current host.
        The host is extracted from the url.
        Maybe a specific css could be loaded from this remote machine.
        */
        LoadUrlUpdateDisplay(adaptedUrl,true);
    }
    else
    {
        alert("Cannot drop url:"+droppedUrl);
    }



};

function onDragOver(evt){
    console.log("onDrag evt="+JSON.stringify(evt))
    evt.preventDefault();
}

function D3DisplayCreation()
{
    'use strict';

    function MyZoom() {
        divSvg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    }

    var win = window;
    var doc = document;
    var elt = doc.documentElement;
    var geb = doc.getElementsByTagName('body')[0];

    geb.addEventListener('drop', onDrop);
    geb.addEventListener('dragover', onDragOver, false);

    // First defined and non-zero values.
    wScreen = win.innerWidth || elt.clientWidth || geb.clientWidth,
    hScreen = win.innerHeight|| elt.clientHeight|| geb.clientHeight;

    /*
    Pour la page en D3, on fait comme google maps:
    - On resize avec la roulette.
    - mais la taille doit etre infinie: Ca prend toute la page.
    - Le menu est sur un rectagle surajoute.
    <jst><canvas>

    Plan:
    - OPn commence a creer le petit rectangle toutjours positionne en haut.
    Qq chose de moderne, menus etc...
    - On voit comment D3 peut profiter d'une page entiere.

    */

    // http://stackoverflow.com/questions/16265123/resize-svg-when-window-is-resized-in-d3-js
    // This allows the resizing.
    divSvg = d3.select("body")
        .append("div")
        .classed("svg-container", true) //container class to make it responsive
        .append("svg:svg")
        //responsive SVG needs these 2 attributes and no width and height attr
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", "0 0 " + wScreen + " " + hScreen)

        // style="border-style:solid;border-width:1px;"
        .attr("style","border-style:solid;border-width:1px;")

        //class to make it responsive
        .classed("svg-content-responsive", true)
        // SVG Geometric Zooming https://bl.ocks.org/mbostock/3680999
        .call(d3.behavior.zoom().scaleExtent([0.125, 8]).on("zoom", MyZoom))
        ;

    myForce = d3.layout.force();
} // D3DisplayCreation

// Mais pourquoi data est passe en premier ? au lieu de (error,data ) ?
// Ah peut-etre d2 version 3 au lieu de 4 ?
function CreateDisplay(data)
{
    if( data == null )
    {
        alert("CreateDisplay: Json data is null");
        return;
    }

    // CheckGraph("new",data);
    D3DisplayCreation();

    // Brand new graph, no need to merge.
    previousData = data;
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
} // CreateDisplay

/* Called when adding a new url and merge it to the existing nodes and links.
TODO: When merging networks, look for url_survol which are identical expect
the host, for some types only, where the same object can be detected
on different machines: CIM_ComputerSystem, socket address, Oracle databases etc...
and everything defined in a credentials file.
Another possibility is to have lib_exports.Grph2Json(), for these types,
add a agent-neutral url.
Or add a flag, survol_global_id, telling that the moniker should not depend on the agent.
If so, the key will be the url stripped of the host.

Meme la, ca ne marchera pas forcement, par exemple
avec ces deux representations differentes, de la meme machine:

DESKTOP-NI99V8E
ARP_type	dynamic
IP_address	192.168.0.26
MAC	8C-70-5A-56-CF-7C
Vendor	"Intel Corporate"

192.168.0.26
Vendor	"Intel Corporate"
MAC	8C-70-5A-56-CF-7C

* Soit le nom de la machine est l'adresse IP.
* Ou bien la carte reseau est creee: Soit adresse IP, soit adresse MAC,
et dans tous ces cas on precise le flag survol_global_id
*/
function RefillDisplayMerge(data, currTimeStamp)
{
    // This creates a new list of nodes with new numbers and without the duplicates.
    // The links also, are recreated, with new numbers.
    var previousNodes = previousData.nodes;
    var prevUrlsToIds = {};

    var lenPrevNodes = previousNodes.length;
    var maxAlerts = 3;
    for (var ixNod = 0; ixNod < lenPrevNodes; ixNod++) {
        var urlNode = previousNodes[ixNod].survol_url;
        // console.log("RefillDisplay(1) urlNode="+urlNode);

        // Sanity check:
        if(prevUrlsToIds[urlNode] != undefined)
        {
            // Not too many alerts.
            if(maxAlerts > 0)
            {
                alert("ixNod="+ixNod+" prevUrlsToIds[urlNode] undefined. urlNode="+urlNode);
                maxAlerts--;
            }
        }

        // Normally, at this stage, each URL should appear only once.
        prevUrlsToIds[urlNode] = ixNod;
    }

    // console.log("prevUrlsToIds elements:"+JSON.stringify(prevUrlsToIds));

    // The new numbers of the new nodes are written in the nodes themselves.
    var newNodes = data.nodes;
    var lenNewNodes = newNodes.length;
    for( var ixNod = 0; ixNod < lenNewNodes; ixNod++ )
    {
        var newNod = newNodes[ixNod];
        var urlNode = newNod.survol_url;
        // console.log("RefillDisplayMerge(2) urlNode="+urlNode);

        // Sanity check
        if( urlNode == undefined)
        {
            alert("urlNode undefined. ixNod="+ixNod);
        }

        // Index of the same URL in the current list of nodes.
        var oldIdx = prevUrlsToIds[urlNode];

        if( oldIdx == undefined )
        {
            // Most common case of a new node.
            var idxAppend = previousNodes.length;
            newNod.new_index = idxAppend;
            // The timestamp must already be set.
            if( newNod.survol_timestamp == undefined ) {
                alert("Inconsistent timestamp (1)");
                return;
            }
            // newNod.survol_timestamp = currTimeStamp;

            // Sanity check
            if( idxAppend < lenPrevNodes )
            {
                alert("idxAppend="+idxAppend);
            }

            // The new node is copied at the end.
            previousNodes.push(newNod);
        }
        else
        {
            // The node already exists, no copy, but this merge the input scripts lists.
            newNod.new_index = oldIdx;

            if( previousNodes[oldIdx].survol_input_scripts == undefined )
            {
                alert("Previous node should have input scripts");
                return;
            }

            if( newNod.survol_input_scripts == undefined )
            {
                alert("New node should have input scripts");
                return;
            }

            previousNodes[oldIdx].survol_input_scripts
                = previousNodes[oldIdx].survol_input_scripts.concat(newNod.survol_input_scripts)

            previousNodes[oldIdx].survol_timestamp = currTimeStamp;

            // Sanity check
            if( previousNodes[oldIdx].survol_url != urlNode)
            {
                alert("Inconsistent urls oldIdx="+oldIdx);
            }
        }
    }

    // Now we renumber the edges.
    var newLinks = data.links;
    var lenNewLinks = newLinks.length;
    var previousLinks = previousData.links;
    for( var ixLnk = 0; ixLnk < lenNewLinks; ixLnk++ )
    {
        var newLnk = newLinks[ixLnk];

        var idxSourceMapped = newNodes[newLnk.source].new_index;

        // Sanity check
        if(idxSourceMapped == undefined)
        {
            alert("Source undefined newLnk.source="+newLnk.source);
        }

        newLnk.source = idxSourceMapped;

        var idxTargetMapped = newNodes[newLnk.target].new_index;

        // Sanity check
        if(idxTargetMapped == undefined)
        {
            alert("Target undefined newLnk.target="+newLnk.target);
        }

        // console.log("Rewire "+ixLnk+" target from "+newLnk.target+" to "+idxTargetMapped);
        newLnk.target = idxTargetMapped;

        // Sanity check
        if(newLnk.source == undefined)
        {
            alert("newLnk.source undefined. ixLnk="+ixLnk);
        }
        if(newLnk.target == undefined)
        {
            alert("newLnk.target undefined. ixLnk="+ixLnk);
        }

        // If the source and the targets had to be remapped,
        // it means that the target was already there.
        // However, we insert it again because it should be rare,
        // and the duplicated edge might bring more information.
        previousLinks.push(newLnk);
    }

    // Now a last pass to remove the duplicate nodes.
    var ixNod = 0;
    while(ixNod < lenNewNodes)
    {
        var newNod = newNodes[ixNod];

        // Sanity check
        if(newNod.new_index == undefined)
        {
            alert("newNod.new_index undefined ixNod="+ixNod);
        }

        if(newNod.new_index < lenPrevNodes)
        {
            // The node already exists.
            newNod.new_index = oldIdx;
            newNodes.splice(ixNod,1); // Beware, this might be slow.
            console.log("Removing duplicate ixNod="+ixNod);
            lenNewNodes--;
        }
        else
        {
            ixNod++;
        }
    }

    // Sanity check
    if(lenNewNodes != data.nodes.length)
    {
        alert("Inconsistency lenNewNodes="+lenNewNodes+" data.nodes.length="+data.nodes.length);
    }

    // Sanity check.
    CheckGraph("prev",previousData);
} // RefillDisplayMerge

/* Called when reloading the content of a script which was previously loaded. */
function RefillDisplayRefresh(theUrl,data,currTimeStamp)
{
    var urlNoJson = UrlWithoutJsonMode( theUrl );
    console.log("RefillDisplayRefresh urlNoJson="+urlNoJson+" currTimeStamp="+currTimeStamp);

    if( currTimeStamp == undefined ) {
        alert("Inconsistent timestamp (4)");
        return;
    }


    /* Merge the new content with the old, but the all nodes from the new data set,
    are tagged with a time-stamp. */
    RefillDisplayMerge(data,currTimeStamp);

    CheckGraph("refresh1",previousData);

    /* Delete from the merged grph, the nodes from the same URL but which were not time-stamped,
    which means they did not reappear in the new content of the same URL.
    If they come from several URLs, maybe keep them if one of the other URLs is automatically refreshed
    and has any precedence.
    TODO: IMPLEMENT THIS. For the moment, simplified version. */

    console.log("RefillDisplayRefresh previousData.nodes.length="+previousData.nodes.length);
    for (var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ ) {
        var objNode = previousData.nodes[ixNod];

        console.log("RefillDisplayRefresh ixNod="+ixNod+" survol_input_scripts="+objNod.survol_input_scripts+" timestamp="+objNode.survol_timestamp);
        idxIn = objNod.survol_input_scripts.indexOf(urlNoJson);

        console.log("idxIn="+idxIn);
        if ( idxIn >= 0 )
        {
            console.log("Comparing timestamps");
            if( objNode.survol_timestamp == undefined ) {
                alert("Inconsistent timestamp (2)");
                return;
            }
            if( objNode.survol_timestamp > currTimeStamp ) {
                alert("Inconsistent timestamp (3)");
                return;
            }

            /* This node was not in the new content of the same URL. */
            if( objNode.survol_timestamp < currTimeStamp )
            {
                /* The node does not appear in the new content of the same URL,
                so it must be deleted. */

                // Ensuite refaire le merge si ActiveX.


                console.log("DELETING ixNod="+ixNod);

                // continue; // TEMP TEMP

                /// DeleteD3NodeFromIndex(ixNod);

                previousData.nodes.splice(ixNod,1);

                // At this stage the new nodes still contain an index.
                for( var ixLnk = 0; ixLnk < previousData.links.length; ixLnk++ )
                {
                    objLnk = previousData.links[ixLnk];
                    if( ( objLnk.source == ixNod ) || ( objLnk.target == ixNod ) )
                    {
                        previousData.links.splice(ixLnk,1);
                        ixLnk--;
                        continue;
                    }
                    if(objLnk.source > ixNod) {
                        objLnk.source--;
                    }
                    if(objLnk.target > ixNod) {
                        objLnk.target--;
                    }
                }

                CheckGraph("refresh2 "+ixNod,previousData);
                // Because it will be incremented.
                ixNod--;
            }
        }
    }
    CheckGraph("refresh2",previousData);
} // RefillDisplayRefresh

// This is the host name if the current page, calculated once only.
var hostMine = GetHostFromUrl(window.location.href);


/* This associates a hostname to a color.
This gives a different appearance to nodes based on the host where they are defined.
This does not process collisions. */
function HostToColorNoCache(aHostName)
{
    // https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
    // Calculates a hash with a hostname. This integer hash is used to create a color.
    function HashStringToInt24(aString)
    {
        var hash = 0, i, chr;
        if (aString.length === 0) return hash;
        for (i = 0; i < aString.length; i++) {
            chr   = aString.charCodeAt(aString.length-i);
            hash  = ((hash << 5) - hash) + chr;
            hash |= 0; // Convert to 32bit integer
        }
        if(hash <0)
            hash = -hash;

        return hash % ( 256 * 256 * 256 );
    };

    var hashInt = HashStringToInt24(aHostName);
    var hashStr = hashInt.toString(16);
    var theStr = ("000000" + hashStr).substr(-6);

    // This amplifies color constrast.
    function Amplify(aHex)
    {
        if( "01234".indexOf(aHex) >= 0 ) return "0";
        if( "567".indexOf(aHex) >= 0 ) return "5";
        if( "89a".indexOf(aHex) >= 0 ) return "a";
        if( "bcdef".indexOf(aHex) >= 0 ) return "f";
    }

    var aCol = "#" + Amplify(theStr[0]) + theStr[1] + Amplify(theStr[2]) + theStr[3] + Amplify(theStr[4]) + theStr[5] ;
    // var aCol = "#" + theStr ;
    console.log("+++++++++++++++++++++++ HostToColor hashInt="+hashInt+" hashStr="+hashStr+" aHostName="+aHostName+" => "+aCol);
    return aCol;
}

/* This associates an unique color to a hostname,
using a cache. There is no need to post a message
to the summary window because this is called only when adding a new url.
Therefore the summary window will receive a message anyway.
However, the list of color is stored in the data structure sent to the summary window.
*/
function HostToColor(aHostName)
{
    // Is this host here ?
    var hostObj = lstLoadedUrls.dict_hosts[aHostName];

    if(hostObj == undefined)
    {
        hostObj = {};
        hostObj.m_host_color = HostToColorNoCache(aHostName);
        // Store the color for later use.
        lstLoadedUrls.dict_hosts[aHostName] = hostObj;
    }

    return hostObj.m_host_color;
}

// Callback of contextual menu. It receives the JSON nodes and links sent by the server.
function RefillDisplay(theUrl,data,shouldMerge,currTimeStamp)
{
    'use strict';
	console.log("RefillDisplay entering shouldMerge="+shouldMerge+" currTimeStamp="+currTimeStamp);
    CheckGraph("new",data);
    if( data == null )
    {
        alert("RefillDisplay: Json data is null");
        return;
    }

    // UTC timestamp in milliseconds.
    // var currTimeStamp = Date.now();
    // newNod.survol_timestamp = currTimeStamp

    /* This calculates the stroke color and width for each object,
    based on the host on which it is defined.
    Ths url should normally be from the same host, but this is not a requirement.
    */
    for (var ixNod = 0; ixNod < data.nodes.length; ixNod++ ) {
        var objNode = data.nodes[ixNod];
        objNode.survol_host = GetHostFromUrl(objNode.survol_url);

        if( objNode.survol_host == hostMine ) {
            objNode.survol_width = 1;
            objNode.survol_stroke = "#000000";
        }
        else {
            objNode.survol_width = 2;
            objNode.survol_stroke = HostToColor(objNode.survol_host);
        }
    }


    if( (previousData == null ) || (shouldMerge == false) )
    {
        previousData = data;
    }
    else
    {
        // If the url is already loaded, rather call RefillDisplayRefresh.
        if( shouldMerge == MergeRefreshMode )
        {
            RefillDisplayRefresh(theUrl,data,currTimeStamp);
        }
        else if( shouldMerge == true )
        {
            // If we merge the current nodes and links with the new one.
            RefillDisplayMerge(data,currTimeStamp);
        }
        else
        {
            alert("RefillDisplay Cannot do anything theUrl="+theUrl);
            return;
        }
    }

	console.log("RefillDisplay before EmptyDisplay");

    EmptyDisplay();

	console.log("RefillDisplay before DisplayD3Layout");


	/*
	Probleme dans previousData
	TypeError: r.target is undefined
	*/

    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
    // globalMustMerge = false;
	console.log("RefillDisplay leaving");
} // RefillDisplay

function EmptyDisplay()
{
    'use strict';
    var node = divSvg.selectAll("g.survol_node")
        .data([])
        .exit()
        .remove();

    var link = divSvg.selectAll(".survol_line")
        .data([])
        .exit()
        .remove();

    // previousData = null;
} // EmptyDisplay

/* When deleting a node from the contextual menu. Deletes the nodes and its links. */
function FindIndexFromNode(objectSvg)
{
    'use strict';
    // No need of a lookup because it happens just once.
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        var goodNodeIdx;
        if( previousData.nodes[ixNod].survol_url == objectSvg.survol_url )
        {
            goodNodeIdx = ixNod;
            console.log("FindIndexFromNode found ixNod="+ixNod);
            return goodNodeIdx;
        }
    }

    alert("Could not find url="+objectSvg.survol_url);
    return -1;
} // FindIndexFromNode

function DeleteD3NodeFromIndex(goodNodeIdx)
{
    console.log("DeleteD3NodeFromIndex goodNodeIdx="+goodNodeIdx);
    var goodNode = previousData.nodes[goodNodeIdx];

    // The node is removed and the following node numbers are decremented.
    // Therefore the links must be updated.
    previousData.nodes.splice(goodNodeIdx,1);

    // The link is pointing to the node to be deleted. Each index is replaced by the node itself
    // NOTE: APPARENTLY THE NODE INDICES ARE REPLACED BY THE NODE OBJECT.
    previousData.links = previousData.links.filter(
        function(objLnk) {
            return (objLnk.source != goodNode ) && ( objLnk.target != goodNode );
        });
    console.log("DeleteD3NodeFromIndex previousData.links.length="+previousData.links.length);
}

// Attempt to fix the "use strict"problem with Edge..
globalMustMerge = false;

/* When deleting a node from the contextual menu. Deletes the nodes and its links. */
function DeleteSvgNode(objectSvg)
{
    'use strict';
    var goodNodeIdx = FindIndexFromNode(objectSvg);

    DeleteD3NodeFromIndex(goodNodeIdx);

    EmptyDisplay();
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
    console.log("DeleteSvgNode reset globalMustMerge");
    // BEWARE: On IE / Edge: Not defined.
    globalMustMerge = false;
} // DeleteSvgNode

function MarkToDel(flag)
{
    'use strict';
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        previousData.nodes[ixNod].to_delete = flag;
    }
    for( var ixLnk = 0; ixLnk < previousData.links.length; ixLnk++ )
    {
        previousData.links[ixLnk].to_delete = flag;
    }
} // MarkToDel

// There is no direct way to get the edges connected to one node,
// so this recursively explores the graph and marks objects for deletion.
function DeleteSvgConnectedNodes(objectSvg)
{
    'use strict';

    MarkToDel(false);

    // First, builds for each node, the list of edges starting from it.
    for( var ixNod = 0; ixNod < previousData.nodes.length; ixNod++ )
    {
        previousData.nodes[ixNod].indices_links_list = [];
    }

    // Now target and source point to node object, not indices.
    for( var ixLnk = 0; ixLnk < previousData.links.length; ixLnk++ )
    {
        var objLnk = previousData.links[ixLnk];

        // In this context, the links are bidirectionnal.
        objLnk.source.indices_links_list.push(ixLnk);
        objLnk.target.indices_links_list.push(ixLnk);
    }

    // Recursively marks connected nodes for deletion.
    function RecursAppendConnected(objNod)
    {
        var lstIdxEdges = objNod.indices_links_list;
        objNod.to_delete = true;
        for( var ixEdgeKey in lstIdxEdges )
        {
            var ixEdgeIdx = lstIdxEdges[ixEdgeKey];
            var objLnk = previousData.links[ixEdgeIdx];
            var nodOther = null;
            if( objLnk.target == objNod )
                nodOther = objLnk.source;
            else if( objLnk.source == objNod )
                nodOther = objLnk.target;
            else alert("We have a problem");
            if( nodOther.to_delete == false )
            {
                RecursAppendConnected(nodOther);
            }
        }
    } // RecursAppendConnected

    var goodNodeIdx = FindIndexFromNode(objectSvg);
    var goodNode = previousData.nodes[goodNodeIdx];

    RecursAppendConnected(goodNode);

    // Now we just need to delete.
    // TODO: It may be simpler if the nodes container is indexed with URL, instead of an array.

    previousData.nodes = previousData.nodes.filter( function(objNod) { return ! objNod.to_delete; });

    previousData.links = previousData.links.filter( function(objLnk) {
        return ! ( objLnk.source.to_delete || objLnk.target.to_delete );
    });

    // Same code as for deleting one node.
    EmptyDisplay();
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);
    console.log("DeleteSvgConnectedNodes reset globalMustMerge");
    globalMustMerge = false;
} // DeleteSvgConnectedNodes

////////////////////////////////////////////////////////////////////////////////

/* The list of currently loaded urls.
This is an object array with some extra members.
    lstLoadedUrls.number_nodes  // Total number of nodes after merging.
    lstLoadedUrls.number_links  // Total number of links after merging.
    array_urls[]                // Each URL of the array.
                                // It behaves like a map but we want to be sure of the order.
        m_loaded_url            // The loaded URL itself.
        m_loaded_title
        m_loaded_nodes_length
        m_loaded_links_length
        m_refresh_rate
    dict_hosts{}                // Dictonary of unique hosts of the URLs.
                                // It always grows: Host are never removed, there are not may of them.
                                // It simply maps to a object containing graphic data.
        m_host_color            // An unique color string for nodes of this host.

TODO: This could also be the UNDO list, and therefore will contain "pseudo-urls"
meaning that such or such object was added or removed.
*/

var lstLoadedUrls = {
    number_nodes:0,
    number_links:0,
    array_urls: [],
    dict_hosts: {}
};

// We do not add methods because the object must be cloned when sent as a message.
function lstLoadedUrls_DeleteAll()
{
    for( var idxUrl = 0; idxUrl < lstLoadedUrls.array_urls.length; idxUrl++ )
    {
        lstLoadedUrls_DeleteOne(0);
    }
}

// Deletes an URL in the list and cancels the timer if needed.
function lstLoadedUrls_DeleteOne(idxUrl)
{
    lstLoadedUrls_TimerSet(idxUrl);
    lstLoadedUrls.array_urls.splice(idxUrl,1);
}

var MergeRefreshMode = 2;

// When the url is deleted, the timer must also be cleared.
function TimerRefreshUrl(objLoadedUrl)
{
    console.log("TimerRefreshUrl m_loaded_url="+objLoadedUrl.m_loaded_url);

    urlJson = AppendCgiToUrl(objLoadedUrl.m_loaded_url,"mode=json");

    // TODO: Finish this !! Doing what ??? ...
    LoadUrlUpdateDisplay(urlJson, MergeRefreshMode );
}

function lstLoadedUrls_TimerSet(idxUrl,newRate)
{
    console.log("TimerSet idxUrl="+idxUrl+" newRate="+newRate);
    lstLoadedUrls.array_urls[idxUrl].m_refresh_rate = newRate;
    if( lstLoadedUrls.array_urls[idxUrl].m_timer_refresh != undefined )
    {
        clearInterval(lstLoadedUrls.array_urls[idxUrl].m_timer_refresh);
    }
    if((newRate != undefined) && (newRate != 0))
    {
        // The URL is reloaded every minute.
        lstLoadedUrls.array_urls[idxUrl].m_timer_refresh = setInterval( TimerRefreshUrl, newRate * 60 * 1000, lstLoadedUrls.array_urls[idxUrl] );
    }
} // lstLoadedUrls_TimerSet

// This tells if an URL is already loaded.
function IsLoadedUrl(theUrl)
{
    var urlNoJson = UrlWithoutJsonMode( theUrl );
    for( var idxUrl = 0; idxUrl < lstLoadedUrls.array_urls.length; idxUrl++ )
    {
        console.log("IsLoadedUrl idxUrl="+idxUrl+" url="+lstLoadedUrls.array_urls[idxUrl].m_loaded_url);
        if( urlNoJson == lstLoadedUrls.array_urls[idxUrl].m_loaded_url ) {
            console.log("IsLoadedUrl urlNoJson="+urlNoJson+" already there");
            return true;
        }
    }
    console.log("IsLoadedUrl urlNoJson="+urlNoJson+" not loaded");
    return false;
} // IsLoadedUrl



////////////////////////////////////////////////////////////////////////////////
/* This is called when clicking "Del" on the Summary little window. */
function ProcessSummaryWindowDel(idxUrl)
{
    objLoadedUrl = lstLoadedUrls.array_urls[idxUrl];
    // The URL can be something like "survol/sources_types/enumerate_CIM_Process.py?xid=."
    // It should be identical to what is stored in the nodes.
    objUrlStr = objLoadedUrl.m_loaded_url;
    // console.log("ProcessSummaryWindowDel DelScript:"+objUrlStr);

    for( var ixNd = 0; ixNd < previousData.nodes.length; ixNd++ )
    {
        objNod = previousData.nodes[ixNd];
        // console.log("ixNd="+ixNd+" node="+JSON.stringify(objNod));

        // If the node was created by this script.
        idxIn = objNod.survol_input_scripts.indexOf(objUrlStr);
        // console.log("idxIn="+idxIn);
        if ( idxIn >= 0 )
        {
            // If the node was created only by this script, the delete it.
            if( objNod.survol_input_scripts.length == 1 ) {
                DeleteD3NodeFromIndex(ixNd);
                ixNd--; // One node less.
            } else {
                // Otherwise just remove the URL.
                objNod.survol_input_scripts.splice( idxIn, 1 );
            }
        }
    } // Loop on nodes.

    lstLoadedUrls_DeleteOne(idxUrl);

    // Maybe we could refresh the display at each node ?
    EmptyDisplay();
    DisplayD3Layout(divSvg,previousData,wScreen,hScreen);

    RefreshSummaryWindow();
} // ProcessSummaryWindowDel

/* Messages received from the Summary window are made of a vector: The first element is a string
which indicates the type of operation. */
function ProcessSummaryWindowMessages(event)
{
    // event={"isTrusted":false}
    // "DelScript:0"
    var msgSent = event.data;
    // "http://192.168.1.83"
    var msgOrig = event.origin;
    var keyWord = msgSent[0];
    console.log("msgSent="+msgSent+" msgOrig="+msgOrig+" event="+JSON.stringify(event));

    if(keyWord == 'ChangeRate')
    {
        var idxUrl = msgSent[1];
        var newRate = msgSent[2];
        console.log("newRate="+newRate+" idxUrl="+idxUrl);

        lstLoadedUrls_TimerSet(idxUrl,newRate);
    } else if(keyWord == 'DelScript')
    {
        idxUrl = msgSent[1];
        ProcessSummaryWindowDel(idxUrl);
    } // If delete nodes exclusive from a script.

} // ProcessSummaryWindowMessages

console.log("Initializing windowObjectReference");

// Declare it but with an invalid value.
var windowObjectReference = null;

/* This is called when a URL is loaded. It updates the little Summary window
by sending as a message the list of loaded urls. */
function RefreshSummaryWindow()
{
    if(windowObjectReference) {
        console.log("RefreshSummaryWindow: Sending message to summary window lstLoadedUrls.array_urls.length="+lstLoadedUrls.array_urls.length);
        lstLoadedUrls.number_nodes = previousData.nodes.length;
        lstLoadedUrls.number_links = previousData.links.length;

        windowObjectReference.postMessage(lstLoadedUrls,"*");
    } else {
        console.log("RefreshSummaryWindow: Summary window not created");
    }
    return;
} // RefreshSummaryWindow

/* Add the origin URL to each node. This is used for example to selectively delete nodes
coming from a specific URL, or to refresh the result of an URL. Note that URL and scripts
have the same meaning in this file: Python scripts returning JSON data and invoked as HTTP URLs. */
function NodeSetInputScript(urlObj,theData)
{
    // UTC timestamp in milliseconds.
    var currTimeStamp = Date.now();

    // Maybe could use a regular expression.
    var urlObjRaw = UrlWithoutJsonMode( urlObj );
    console.log("NodeSetInputScript urlObj="+urlObj+" NumNodes="+theData.nodes.length);
    // Loop on the nodes and add the url.
    for( var ix = 0; ix < theData.nodes.length; ix++ )
    {
        objNod = theData.nodes[ix];

        // We know that the object is freshly loaded, so we can create a new list.
        objNod.survol_input_scripts = [urlObjRaw];

        objNod.survol_timestamp = currTimeStamp;
    }

    return currTimeStamp;
} // NodeSetInputScript

/* Each node remembers the script which created it.
The "options" parameter comes from contextMenu which passes it to the callback. */
function RememberCallback(options, urlObj, data)
{
    console.log("RememberCallback urlObj="+urlObj+" NumNodes="+data.nodes.length);
    var currTimeStamp = NodeSetInputScript(urlObj,data)

    var menuOptions = {};
    $.contextMenu.getInputValues(options, menuOptions);
    // This applies to the two types of contextual menu: Per node or general.
    shouldMerge = menuOptions.yesno;

    // Now process the new nodes. Duplicate nodes will have two sources or more.
    RefillDisplay(urlObj, data, shouldMerge, currTimeStamp );
}


/* Loads from a URL, a JSON document made of nodes and links.
After that, updates a table containing the list of loaded URLs. */
function LoadUrlUpdateDisplay(theUrl,shouldMerge)
{
    'use strict';

    console.log("LoadUrlUpdateDisplay theUrl="+theUrl);

    if( theUrl.indexOf("entity_mime") >= 0 )
    {
        console.log("Getting close");
    }

    if( shouldMerge == false ) {
        // Each element must be properly destroyed.
        lstLoadedUrls_DeleteAll();
    }

    // This is called by a JSON document loaded from a Python script.
    function LoaderCallback(error,data)
    {
        console.log("LoaderCallback theUrl="+theUrl+" error="+error);
        if(error) {
            alert("LoaderCallback: theUrl="+theUrl+" error="+JSON.stringify(error));
        }

        if( data == null )
        {
            console.log("LoaderCallback: data is null");
            return;
        }

        console.log("data="+JSON.stringify(data));
        if( data.status == "error" )
        {
            alert("Error agent:"+data.message);
            return;
        }

        if( data.survol_error != undefined )
        {
            alert("Error:"+data.survol_error);
            return;
        }

        // This merges the new data with the current one.
        // Each node remembers the script which created it.
        var currTimeStamp = NodeSetInputScript(theUrl,data);

        var actualMergeMode = shouldMerge;
        if( IsLoadedUrl(theUrl) ) {
            actualMergeMode = MergeRefreshMode;
        }

        /*
        Here, we must set a specific graphic attribute for this machine.
        This attribute is set to the loaded nodes.
        Or, we create a dictionary mapping host names to graphic attributes.
        
        */

        RefillDisplay(theUrl,data, actualMergeMode, currTimeStamp);

        // If refresh, do not change the list of loaded urls.
        var urlNoJson = UrlWithoutJsonMode( theUrl )
        if( actualMergeMode != MergeRefreshMode )
        {
            var objLoadedUrlNew = {
                m_loaded_url : urlNoJson,
                m_loaded_title : data.page_title,
                m_loaded_nodes_length : data.nodes.length,
                m_loaded_links_length : data.links.length
                };
            lstLoadedUrls.array_urls.push(objLoadedUrlNew);
        }
        else
        {
            var objUrl;
            for( var ixUrl = 0; ixUrl < lstLoadedUrls.array_urls.length; ++ixUrl )
            {
                objUrl = lstLoadedUrls.array_urls[ixUrl];
                if( objUrl.m_loaded_url == urlNoJson )
                {
                    console.log("Updating url ixUrl="+ixUrl);
                    objUrl.m_loaded_nodes_length = data.nodes.length;
                    objUrl.m_loaded_links_length = data.links.length;
                    break;
                }
            }
            if( objUrl == undefined )
            {
                alert("Cannot find url ixUrl="+ixUrl);
                return;
            }
        }

        RefreshSummaryWindow();
    } // LoaderCallback


    /* TODO: If theUrl="http://127.0.0.1:8000/survol/merge_scripts.py?url=aHRiaW4vc...",
    then parse the URLs, and load each of them. */
    console.log("LoadUrlUpdateDisplay theUrl="+theUrl);

    if(isDragging) {
        console.log("NoUrl loading when dragging");
        return;
    }

    // Removes immediately tooltip if it is here.
    if(divTooltip) {
        divTooltip.style("opacity", 0);
    }

	try
	{
		// The Python script might fail.
		d3.json(theUrl, LoaderCallback );
	}
	catch(exc)
	{
		console.log("LoadUrlUpdateDisplay caught:"+exc);
		var emptyData = {
			nodes: [],
			links: []
		};
		LoaderCallback(null,emptyData);
	}
} // LoadUrlUpdateDisplay

// This checks if there is already a CGI argument.
function AppendCgiToUrl(url,cgipair)
{
	if( url.indexOf("?") < 0 )
		return url + "?" + cgipair;
	else
		return url + "&" + cgipair;
}

/* Ad-hoc solution to remove the mode from a URL. */
function UrlWithoutJsonMode(theUrl)
{
    return theUrl.replace("?mode=json","").replace("&mode=json","")
}

/* This approximates the Survol agent with the host name of the URL.
This works because a Survol agent is uniquely associated with a host name
and a port number, because this is a plain HTTP server.
Taken from "URI Parsing with Javascript"
https://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript
*/
function GetHostFromUrl( aSurvolUrl )
{
    var parser = document.createElement('a');
    parser.href = aSurvolUrl; // "http://example.com:3000/pathname/?search=test#hash";
    return parser.host;
} // GetHostFromUrl

function DisplayD3Layout(divSvg,newData,w,h)
{
    'use strict';
    console.log("DisplayD3Layout newData.nodes="+newData.nodes.length+" newData.links="+newData.links.length);

    function tick_function()
    {
        /* Apply the constraints: On verra plus tard.
        using layout.force to plot tree graphs (where nodes may have multiple parents) - Part 1: pure tree
        http://bl.ocks.org/GerHobbelt/3669455
        */

        link.attr("x1", function (d) { return d.source.x; })
            .attr("y1", function (d) { return d.source.y; })
            .attr("x2", function (d) { return d.target.x; })
            .attr("y2", function (d) { return d.target.y; });

        // http://mbostock.github.io/d3/talk/20110921/bounding.html
        selectedNodes.attr("transform", function (d) {
            /*
            // Ca fonctionne mais ca n'est pas tres beau.
            var rr = 10;
            d.x = Math.max(rr, Math.min(w - rr, d.x));
            d.y = Math.max(rr, Math.min(h - rr, d.y));
            */

            return "translate(" + d.x + "," + d.y + ")";
        });
    }

	// console.log("newData.nodes"+JSON.stringify(newData.nodes));
	// console.log("newData.links"+JSON.stringify(newData.links));
	
    // It is possible to link nodes by names in D3 v4: https://bl.ocks.org/mbostock/533daf20348023dfdd76
    myForce
        .nodes(newData.nodes)
        .links(newData.links)
        .distance(100)
        .charge(-1000)
        .linkDistance(100)
        .size([wScreen, hScreen])
        .on("tick", tick_function)
        .start();

    var link = divSvg.selectAll(".survol_line")
        .data(newData.links)
        .enter().append("svg:line")
        .attr("class", function (d) { return "survol_line"; })
        .attr("x1", function (d) { return d.source.x; })
        .attr("y1", function (d) { return d.source.y; })
        .attr("x2", function (d) { return d.target.x; })
        .attr("y2", function (d) { return d.target.y; })
        // "Error in parsing value for "markedr-end": This is why I removed this.
        // .attr("marker-end", function (d) { if (d.value == 1) { return "url(#arrowhead)"; } else { return " "; }; })
        // .append("svg:title").text(function(d) { return d.link_prop; })
        ;

    // Creates one SVG object (Which class ?) for each survol node.
    // CA DEVRAIT ALLER POUR AJOUTER DES NODES.
    var selectedNodes = divSvg.selectAll("g.node")
        .data(newData.nodes)
        .enter().append("svg:g")
        .attr("class", function (d)
            {
                return "survol_node node " + d.entity_class;
            }
        ) // Several classes are possible.
        .call(myForce.drag);

	/* https://stackoverflow.com/questions/30723592/prevent-click-action-when-dragging-a-d3-node
	When combining drag with other event listeners,
	stop propagation on the source event to prevent multiple actions.
	Otherwise, dragging also triggers the click behavior when the mouse is released. */

    // var d3BehDrag = d3.behavior.drag();
    var d3BehDrag = myForce.drag();
    d3BehDrag
        .on("dragstart", function() {
            isDragging = true; // This avoids the tooltip when dragging.
            // Tooltip ne fonctionne plus !!!
            console.log("Tooltip disabled");
        })
        .on("dragend", function() {
            d3.event.sourceEvent.stopPropagation(); // silence other listeners
            isDragging = false; // Tooltip when hovering is now allowed.
            console.log("Tooltip enabled");
        })
        ;

    // fill:#337147;

    // Define the div for the tooltip.
    // If set globally, it is null here.
    divTooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0.5)
        ;

    // Used for the tooltip containg literal nodes pointing to a given node, i.e. information.
    // TODO: This should be recursive.
    function DictToTable(theList,theDict)
    {
        var result = "<table>"
        for (var ix in theList) {
            result += "<tr><td valign='top' align='left' colspan='2'><b>" + theList[ix] + "</td></tr>";
        }
        for (var key in theDict) {
            if (theDict.hasOwnProperty(key)) {
                result += "<tr><td valign='top' align='left'><b>" + key + "</b></td><td valign='top' align='left'>" + theDict[key] + "</td></tr>";
            }
        }
        result += "</table>";
        return result;
    } // DictToTable

    // https://bl.ocks.org/mbostock/7555321 Wrapping Long Labels
    function addTextLines(selection) {
        selection.each(function(d) {
            var theText = d3.select(this);
            // This is the first line of the box.
            theText.text(null).append("tspan").attr("x", 0).text(d.name);

            // Now it displays one line for each information about the node.
            var cntLine = 0;

            for (var ix in d.survol_info_list) {
                theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(d.survol_info_list[ix]);
            }

            for (var key in d.survol_info_dict) {
                if (d.survol_info_dict.hasOwnProperty(key)) {
                    var txtKeyVal = key + "=" + d.survol_info_dict[key];
                    theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(txtKeyVal);
                }
            }

            // info_list
            // theText.append("tspan").attr("x", 0).attr("dy", 1 + "em").text(d.name);
        })
    } // addTextLines

    function getTextBox(selection) {
        selection.each(function(d) { d.bbox = this.getBBox(); })
    }

    // This is the text associated to each survol node.
    selectedNodes.append("svg:text")
        // .attr("class", "nodetext " + d.entity_class) // Ca marche pas.
        .attr("class", "nodetext")
        .attr("dx", 0)
        .attr("dy", ".35em")
        .attr("text-anchor", "middle")
        // .text(function (d) { return d.name; }) // Use tspan and tref ???
        // .text(function (d) { return '<tspan>' + d.name + '</tspan><tspan dy="10">First line.</tspan>'; }) // Use tspan and tref ???
        .call(addTextLines)
        .call(getTextBox)
    ;

    // Adds text inside each "g" object of class "survol_node": http://stackoverflow.com/questions/6725288/svg-text-inside-rect
    // Inserts the rect element before the text, which is therefore not hidden.
    // The node must be in "survol_node" and with the class
    d3.selectAll(".survol_node").insert("rect","text")
        .attr("x", function(d){return d.bbox.x})
        .attr("y", function(d){return d.bbox.y})

        // Ces attributs vont refleter un calcul car on peut toujours les appliquer.
        // Bizarrement, pas moyen d'overrider rx et ry avec CSS.
        .attr("rx", 5) // Pas moyen d'overrider ca avec CSS
        .attr("ry", 5)
        .attr("opacity", 1)

        .attr("width", function(d){return d.bbox.width})
        .attr("height", function(d){return d.bbox.height})
        .attr("stroke-width", function (d) { return d.survol_width; } )
        .attr("stroke", function (d) { return d.survol_stroke; } )
        // Classes are not defined so fill colors are OK. We will fetch CSS in classes directories.
        .attr("fill", function (d) {
            if(d.survol_fill)
                // Returned by the Python script.
                return d.survol_fill;
            else
                // Default value which applies for ActiveX if there is no CSS.
                return "#E0E0E0";
        })
        // This allows to apply a CSS with the same name.
        .attr("class", function (d) { return d.entity_class; })
        .on("mouseover", function(d)
            {
                // No tooltip creation when dragging because it is very CPU-consuming.
                if(isDragging) {
                    console.log("No tooltip when dragging");
                    return;
                }
                d.is_mouseover = true;

                // Loading a URL is very heavy. Maybe we should wait some tenths of seconds to check
                // if we are still on this node, before loading the tooltip.
                function IfMouseOver(d,currentEventD3pageX,currentEventD3pageY)
                {
                    if( false == d.is_mouseover ) {
                        console.log("MouseOver too late");
                        return;
                        }
                    if( isDragging ) {
                        console.log("IfMouseOver not when dragging");
                        return;
                        }

                    // This object probably comes from WMI only.
                    // TODO: We could still have a URL and rather check if a server is here ??
                    if( ! d.survol_url ) {
                        console.log("No script data without URL");
                        return;
                        }
						
                    // d.survol_info_dict is a dictionary, and survol_info_list is a list.
                    // These two members are filled when parsing the input JSON document.

                    // On OVH, we have this URL:
                    // d.survol_url=http://www.primhillcomputers.com:80/survol/survolcgi.py?script=/entity.py&amp;xid=user.Domain=ovh.net,Name=lp
                    console.log("IfMouseOver d.survol_url="+d.survol_url);
                    var urlReplaced = d.survol_url.replace("entity.py","entity_info_only.py");
                    var urlTooltip = AppendCgiToUrl(urlReplaced,"mode=json");

                    // "urlTooltip=http://127.0.0.1:8000/survol/entity_info_only.py?xid=rabbitmq/connection.Url=LOCALHOST:12345,Connection=127.0.0.1:51759 -&gt; 127.0.0.1:5672&mode=json"

                    console.log("Loading urlTooltip="+urlTooltip);

                    d3.json(urlTooltip,
                        function(error,objTooltip)
                        {
                            function DisplayTooltipDiv(theTooltipText)
                            {
                                console.log("DisplayTooltipDiv theTooltipText="+theTooltipText);

                                // http://stackoverflow.com/questions/36326683/d3-js-how-can-i-set-the-cursor-to-hand-when-mouseover-these-elements-on-svg-co
                                // This could as well be done in CSS, but we might wish not change the pointer if no link is available, i.e. faulty node.
                                d3.select(this).style("cursor", "pointer");

                                divTooltip.transition()
                                    .duration(200)
                                    .style("opacity", .9);

                                divTooltip.html( theTooltipText )
                                    .style("left", (currentEventD3pageX) + "px")
                                    .style("top", (currentEventD3pageY - 28) + "px");
                            }

                            if(error)
                            {
                                var errMsg = "Tooltip error:" + error;
                                DisplayTooltipDiv(errMsg);
                                return;
                            }
                            console.log("Callback urlTooltip="+urlTooltip+ " objTooltip="+JSON.stringify(objTooltip));
                            if( objTooltip.survol_error != undefined )
                            {
                                var errMsg = "Tooltip objTooltip.survol_error="+objTooltip.survol_error;
                                DisplayTooltipDiv(errMsg);
                                return;
                            }
                            if( false == d.is_mouseover ) {
                                console.log("After tooltip loaded: too late");
                                return;
                                }

                            if( isDragging ) {
                                console.log("No tooltip when dragging");
                                return;
                                }

                            if( objTooltip == null ) return ;
                            if( typeof(objTooltip.nodes) == 'undefined' ) return ;
                            if( typeof(objTooltip.nodes[0]) == 'undefined' ) return ;

                            // THIS MUST BE REPLACED BECAUSE UGLY AND NOT FLEXIBLE.
                            var objInfo = objTooltip.nodes[0].survol_info_dict
                            if ( typeof(objInfo) != 'undefined')
                            {
                                var txtTooltip = DictToTable([],objInfo);
                                DisplayTooltipDiv(txtTooltip);
                            }
                        }
                    );
                } // IfMouseOver

                var currentEventD3 = d3.event;

                // Tooltip starts only after 500 milliseconds.
                setTimeout( function() { IfMouseOver(d,currentEventD3.pageX,currentEventD3.pageY); } , 500 );
            }
        )
        .on("mouseout", function(d)
            {
                // console.log("Resetting MouseOver");
                d.is_mouseover = false;

                // This could as well be done in CSS.
                d3.select(this).style("cursor", "default");

                divTooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }
        )
        .on("click", function(d)
            {
                // TODO: Disabled for the moment because we do not know how to
                // make it work with drag. Consider double-click ??
                // This option is not mandatory because it is still possible to right-click.
                console.log("CLICK is disabled");
                return;

                // Removes immediately tooltip if it is here.
                // divTooltip.style("opacity", 0);

                // This expects a graph, not a contextual menu.
                var aUrl = AppendCgiToUrl( d.survol_url, "mode=json");
                console.log("aUrl="+aUrl);
                LoadUrlUpdateDisplay(aUrl, false);
            })
        ;

    var radius = d3.scale.log().domain([0, 312000]).range(["10", "50"]);

    // Is that to avoid collisions ? Is the drag needed here ?
    d3.selectAll(".circle").append("circle")
        .attr("class", function (d) { return "node"; })
        // TODO: No change when it is commented out.
        //.attr("r", function (d) { return radius(d.value) || 10; })
        .call(myForce.drag);

    // This returns the contextual menu for nodes.
    function MakeContextMenuItems(objectSvg)
    {
        // SHOULD CALL entity_info_only.py BUT THE PROBLEM IS THAT IT IS NOT THE ORIGINAL NODE
        // SO THERE IS A CONFUSION WITH entity.py THAT EVERYTHING RELIES ON.
        // ALSO, WHEN mode=json WE SHOULD NOT DISPLAY THE WBEM AND WMI LINKS AND THE SCRIPTS.
        // MAYBE A ANOTHER MODE NEEDED FOR JUST TEXT INFORMATION FOR THE TOOLTIP.
        // BUT THIS IS VERY HEAVY TO CALL THIS EACH TIME WE HOVER OVER A NODE.
        var objUrl = objectSvg.survol_url;
        console.log("MakeContextMenuItems objUrl="+objUrl);

        var objKey = objectSvg.name;

        var objDeferScripts = objectSvg.defer_scripts;
        console.log("MakeContextMenuItems objKey="+objKey);

        /* Peut-etre ajouter des URLs specifiques pour WMI et OpenWBEM ce qui justifierait qu'on aie
        des scripts Python specifiques.
        */

        var TheItems = {};

        // This is the title, and it is clickable.
        TheItems[ objUrl ] =
        {
            name: objKey
        };

        // If CIM_DataFile, this creates a MIME link on the fly.
        function urlCIM_DataFileToMime(url)
        {
            if(url.indexOf("survol/entity.py?xid=CIM_DataFile.") < 0)
                return null;
            return url.replace("survol/entity.py","survol/entity_mime.py");
        }

        var urlMime = urlCIM_DataFileToMime(objUrl);
        if(urlMime) {
            TheItems[urlMime] = {
                "name": "Mime Display",
                "icon": "paste"
            };
        }

        /*
        Get a list of KV pairs with the parameters.

        We must edit the parameters of the script, not of the object.
        When executing a script, it must send its parameters in JSON, in a special format,
        optional, which does not change the nodes/links data.

        Submitting means:
        - Removing the URL.
        - Create a new URL
        - Load and merge it.

        What does it mean to edit the parameters of an object ?
        We would have to reload "entity" but this mean chaning the object and
        also everything linked to it.
        But we keep open the possibility to act upon an object,
        or change future display parameters.
        To prepare this, we should find a general parameter which always applies.
        */

        // Not needed if this is an external URL.
        if( objUrl.indexOf("survol/") >= 0 ) {
            // By default, results of scripts is merged with the current graph.
            var TheItemsSuite =
            {
                "yesno": {
                    name: "Merge graphs",
                    type: 'checkbox',
                    selected: true
                }
                /* ,
                "disp_all": {
                    name: "Display all scripts",
                    type: 'checkbox', // type: 'text',
                    // value: "Test data",
                    selected: false,
                    events: {
                        keyup: function(e) {
                            // add some fancy key handling here?
                            window.console && console.log('key: '+ e.keyCode);
                        }
                    }
                }
                */
            };
            jQuery.extend(TheItems, TheItemsSuite);
        }

		// Maybe there are Python scripts for this object.
		if(objDeferScripts) {
			// https://swisnl.github.io/jQuery-contextMenu/demo/async-promise.html Submenu through promise.
			var menusSurvol = objDeferScripts.promise();

			var TheItemsScripts = {
				"sep1": "---------",
				"SurvolMenu": {
					name: "Scripts...",
					items: menusSurvol,
				}
			};
			jQuery.extend(TheItems, TheItemsScripts);
		}

		// objectSvg contains the original object created from the WMI command.
		// But it might also simply contain the attribute taken from the URL ?
		// Or we should parse the URL and add the properties into it (and the class),
		// so we could query from WMI with just our properties ??
		// Problem with Base64 ? But why not detecting on the fly if a string is Base64-encoded ??
		// PROBLEM: We have lost the class used from the query. This is not:
		// "CreationClassName, "CSCreationClassname", "OSCreationClassName".
		// Or is it in "entity_class" ?
		// TODO: Should add it.
		if(objUrl) {
			console.log("Calling ActiveX_WMI_JContextMenu objUrl="+objUrl);

			// This creates a clickable item which calls RefillDisplay with the associators objects
			// transformed into a JSON graph.

			var TheItemsSuiteActiveX = ActiveX_WMI_JContextMenu(objUrl,objectSvg, RememberCallback );

			// console.log("Called ActiveX_WMI_JContextMenu objUrl="+objUrl);
			if( TheItemsSuiteActiveX != [] )
			{
				jQuery.extend(TheItems, TheItemsSuiteActiveX);
			}
		}

        var TheItemsSuiteDels =
        {
            "delete_node": {
                "name": "Delete node",
                "icon": "delete"
            },
            "delete_connected": {
                "name": "Delete connected nodes",
                "icon": "delete"
            }
        };
        jQuery.extend(TheItems, TheItemsSuiteDels);

        return TheItems;
    } // MakeContextMenuItems

    /* This returns the contextual menu for the background.
    It is immediately superseded, and the sample data are here just for documentation.
    It contains example data, to explain its structure. */
    function MakeDefaultContextMenuItems(objectSvg)
    {
        var theDfltItems =
        {
            "xxxx": {
                name: "xxxx",
                type: 'checkbox',
                selected: false
            },
            "yyyy": {
                "name": "yyyyy",
                "items": {
                    "edit": {"name": "Edit", "icon": "edit"},
                    "cut": {"name": "Cut", "icon": "cut", disabled: true},
                    "quit": {"name": "Quit", "icon": "quit"}
                }
            }
        };
        return theDfltItems;
     } // MakeDefaultContextMenuItems


    /* Called after the page is loaded. It adds a context menu to each node,
    therefore the nodes must be created. A lot of information here:
    https://github.layalk.net/jQuery-contextMenu/docs.html */
    function CreateContextMenus(){
        console.log("CreateContextMenus");

        // Goes to the right URL given the selected key of a contextual menu.
        function FromKeyToScript(key, options)
        {
            // We will merge the new content with the existing content or not.
            var menuOptions = {};
            $.contextMenu.getInputValues(options, menuOptions);
            // This applies to the two types of contextual menu: Per node or general.

            // This is a Python script, but not a contextual menu displayed by "entity.py".
            var theUrl = AppendCgiToUrl( key, "mode=json");
            console.log("FromKeyToScript theUrl="+theUrl);
            LoadUrlUpdateDisplay(theUrl, menuOptions.yesno );
        }

        // For an URL which returns HTML and to be opened in its own window.
        // Similar to ScriptForJson in Python.
        function PlainNonEntityUrl(url)
        {
            if( url.indexOf("survol/entity_mime.py") >= 0 )
            {
                return true;
            }
            if( url.indexOf("survol/") >= 0 )
            {
                return false;
            }
            // This is a foreign URL
            return true;
        } // PlainNonEntityUrl

        $.contextMenu(
        {
            selector: 'g.survol_node',

            build: function($trigger, evt) {
                // This callback is executed every time the menu is to be shown
                // Its results are destroyed every time the menu is hidden
                // evt is the original contextmenu event, containing evt.pageX and evt.pageY (amongst other data)

                // In JSON format, the node on which we have right-clicked.
                var objectSvg = $trigger["0"]["__data__"];

                var theItems = MakeContextMenuItems(objectSvg);

                return {
                    // This is executed when an option is chosen in a contextual menu.
                    callback: function(key, options)
                    {
                        if(key == "delete_node")
                        {
                            // TODO: Have a specific callback.
                            DeleteSvgNode(objectSvg);
                        }
                        else if(key == "delete_connected")
                        {
                            DeleteSvgConnectedNodes(objectSvg);
                        }
                        else
                        {
                            if( PlainNonEntityUrl(key) )
                            {
                                window.open(key, '_blank','location=no,height=570,width=520,scrollbars=yes,status=yes');
                                return;
                            }
                            FromKeyToScript(key, options);
                        }
                    },
                    items: theItems
                };
            }
        });

        var dfltItms = MakeDefaultContextMenuItems();

        /* There is one default menu, loaded once and for all,
        and it does not use the "promise" feature of the library.
        Therefore it is built asynchronously. */

        // Adds a context menu for the background.
        function AddsDefaultCtxtMenu(error,dfltItms)
        {
            console.log("AddsDefaultCtxtMenu entering");
            if(error) {
                alert("AddsDefaultCtxtMenu error="+error);
            }
            if( dfltItms.survol_error != undefined )
            {
                alert("Error:"+dfltItms.survol_error);
                return;
            }
            $.contextMenu(
            {
                selector: 'svg',
                build: function($trigger, evt) {
					// This does not need the Python HTTP server.
					console.log("ActiveX_WMI_JCtxtMenuGlobal before");

					var activeXDefaultMenus = ActiveX_WMI_JCtxtMenuGlobal( RememberCallback );

					console.log("ActiveX_WMI_JCtxtMenuGlobal after");
					if( activeXDefaultMenus )
					{
					    console.log("activeXDefaultMenus="+JSON.stringify(activeXDefaultMenus));
        				dfltItms["sep2"] = "---------";

						dfltItms["wmiglobal"] = {
							name: "WMI Globals",
							"items" : activeXDefaultMenus
						};
					}

                    // This adds an extra item to the menu returned by a Python script.
                    dfltItms["yesno"] = {
                        name: "Merge graphs",
                        type: 'checkbox',
                        selected: false
                    };

                    return {
                        callback: function(key, options)
                        {
                            console.log("callback key="+key);
                            FromKeyToScript(key, options);
                        },
                        items: dfltItms
                    };
                }
            });
            console.log("AddsDefaultCtxtMenu leaving");
        } // AddsDefaultCtxtMenu

        // This returns the top-level options as a JSON tree.
        var urlTopLevel = AddUrlPrefix( "entity_dirmenu_only.py", "mode=menu");

		try {
			d3.json(urlTopLevel, AddsDefaultCtxtMenu);
		}
		catch(exc)
		{
			console.log("CreateContextMenus caught:"+exc);
			var emptyItems = {
				"Nothing" : {
                        name: "Empty menu",
                        type: 'text'
                    }
				};

			AddsDefaultCtxtMenu(null, emptyItems);
		}
    }; // CreateContextMenus


    // When the mouse right button is down, this loads the contextual menu content into the SVG object.
    // Releasing the right button triggers the contextual menu whose content is in the SVG object.
    $("g.survol_node").mousedown(function(ev){
        // If left click, it should call entity.py.

        function GetEntityUrl(error,jsonData)
        {
            if(error) {
                alert("GetEntityUrl error="+error+" jsonData="+jsonData);
                return;
            }
            if( jsonData.error != undefined )
            {
                alert("Error:"+jsonData.error);
                return;
            }
            // Maybe this duplicates the value. Not a problem.
            objectThis.__data__.contextual_menu_items = jsonData;

            objectThis.__data__.defer_scripts.resolve(jsonData);
        }

        if(ev.which == 3)
        {
            var objectThis = this;

            // If this was defined from a Python script.
            if(this.__data__.survol_url) {
                console.log("Right click on URL="+this.__data__.survol_url);
                if(this.__data__.survol_url.indexOf("entity.py") < 0) {
                    /*
                    Very special case of the execution of file_directory.py : It returns CIM_DataFile and
                    CIM_Directory, but also links to file_directory.py with the entity type CIM_Directory.
                    So these nodes become also clickable.
                    */
                    console.log("Should not happen: only entity.py is clickable");
                    return;
                }
                // We expect a contextual menu in JSON format, not a graph.
                // TODO: Have a script which returns only the menu tree in json, without the intermediate
                // step of RDF encoding.
                var urlEntityNoMode = this.__data__.survol_url.replace("entity.py","entity_dirmenu_only.py")
                var urlEntity = AddUrlCgiArg( urlEntityNoMode, "mode=menu");

                console.log("urlEntity:"+urlEntity);

                this.__data__.defer_scripts = jQuery.Deferred();

                // This loads the menu options as a JSON tree.
                d3.json(urlEntity, GetEntityUrl);
            }
        }
    });

    // Call function after page load: http://stackoverflow.com/questions/890090/jquery-call-function-after-load
    // $(CreateContextMenus);
    CreateContextMenus();
} // DisplayD3Layout

// At startup. This special case because hosting on OVH is specific.
var urlInit = null;
var ixPrim = window.location.hostname.indexOf("primhillcomputers.com");
if( ixPrim >= 0 )
    urlInit = AddUrlPrefix( "sources_types/Linux/etc_passwd.py", "xid=.&mode=json");
else
    urlInit = AddUrlPrefix( "sources_types/enumerate_CIM_Process.py", "xid=.&mode=json");


/* The calling URL might as well be:
http://192.168.1.88/Survol/survol/entity.py?xid=smbshr.Id=////WDMyCloudMirror/rchateau
http://127.0.0.1:8000/survol/sources_types/CIM_Directory/file_directory.py?xid=file.Id%3DC%3A\windows\system32
*/

function BuildSubUrlsListFromCgi(cgiArgs)
{
    'use strict';
    var splitCgiArgs = cgiArgs.split("&");
    var arrUrls = [];

    for(var kvpIdx in splitCgiArgs)
    {
        var kvp = splitCgiArgs[kvpIdx];
        var splitKVP = kvp.split("=");
        if( splitKVP.length == 2)
        {
            if(splitKVP[0] == "url")
            {
                arrUrls.push(splitKVP[1]);
            }
        }
    }
    return arrUrls;
} // BuildSubUrlsListFromCgi

function BuildSubUrlsListFromJson(theInputUrls)
{
    'use strict';
    var arrUrls = [];

    for( var idx in theInputUrls )
    {
        var cgiPair = theInputUrls[idx];
        if( cgiPair.cgi_key == "url" )
        {
            arrUrls.push(cgiPair.cgi_value);
        }
    }
    return arrUrls;
} // BuildSubUrlsListFromJson

var globalIsCreated = false;

function PreloadUrlsArray(urlsArray)
{
    'use strict';

    D3DisplayCreation();

    var numUrls = 0;
    for( var idx in urlsArray )
    {
        var aUrlB64 = urlsArray[idx];
        var aUrlRel = Base64.decode(aUrlB64);

        var idxScriptStart = aUrlRel.indexOf(pyMergeScript);
        console.log("PreloadUrlsArray idx="+idx+" idxScriptStart="+idxScriptStart+" globalIsCreated="+globalIsCreated+" aUrlRel="+aUrlRel);
        if( idxScriptStart != -1 ) {
            var idxScriptEnd = idxScriptStart + pyMergeScript.length;
            var cgiArgs = aUrlRel.substring( idxScriptEnd + 1 );

            var arrUrls = BuildSubUrlsListFromCgi(cgiArgs);
            PreloadUrlsArray(arrUrls);

            numUrls += arrUrls.length;
        } else {

            var aUrlNoMode = aUrlRel;

            // This reasonably expects that there is at least one CGI argument.
            var aUrlMode = AppendCgiToUrl( aUrlNoMode, "mode=json");

            LoadUrlUpdateDisplay(aUrlMode, true );
            numUrls += 1;
        }
    }

    // If not URL on the command line.
    if( numUrls == 0 )
    {
        console.log("No URL to preload");
        LoadUrlUpdateDisplay(urlInit, false);
    }
    return numUrls;
} // PreloadUrlsArray

/* This opens the summary list in a separate window.
It displays the URL which were loaded, how to delete them, how many nodes and links etc... */
function openRequestedPopup() {
    // So the summary window can send messages which are executed in the main window.
    // TODO: Should do it once only.
    window.addEventListener("message", ProcessSummaryWindowMessages, false);

    if( (windowObjectReference == null) || (windowObjectReference.closed))
    {
        console.log("openRequestedPopup creating windowObjectReference");
        windowObjectReference = window.open(
            "summary.htm", // this.href,
            'targetWindow',
            'toolbar=no,location=no,status=no,menubar=no,scrollbars=yes,resizable=yes,directories=no,width=550,height=300'
        );

        // There is a sort of race condition: The summary window id sometimes gets blanked after it is filled.
        windowObjectReference.onload = function() {
            // alert("After create");
            RefreshSummaryWindow();
        };

    } else {
        console.log("openRequestedPopup windowObjectReference created");
    }

    windowObjectReference.focus();
}

function openPrintLayout() {
    var urlPrintLayout = ConcatenateMergeUrl(lstLoadedUrls,"");
    if( location.href.indexOf("primhillcomputers.com") > 0 )
    {
        // This is because graphviz does not run on OVH hosting, for the moment.
        alert("SVG display and Graphviz not yet available on this platform");
        return false;
    }
    location.href = urlPrintLayout;
}

function openHtmlLayout() {
    var urlHtmlLayout = ConcatenateMergeUrl(lstLoadedUrls, "mode=html");
    location.href = urlHtmlLayout;
}

function openConfigurationUrl() {
    var urlConfiguration = AddUrlPrefix("edit_configuration.py", "");
    location.href = urlConfiguration;
}

function RunAfterLoad()
{
    // "getParamValue=[{"cgi_key":"toto","cgi_value":"tutu"},{"cgi_key":"titi","cgi_value":"tata"}]"
    var theInputUrls = GetCgiParams();

    var urlsArray = BuildSubUrlsListFromJson(theInputUrls);

    globalIsCreated = false;
    var numUrls = PreloadUrlsArray(urlsArray);

    console.log("RunAfterLoad finished")

    $(IdHrefSummary).on("click", openRequestedPopup);

    $(IdPrintLayout).on("click", openPrintLayout);
    $(IdHtmlLayout).on("click", openHtmlLayout);
    $(IdConfigurationUrl).on("click", openConfigurationUrl);

    window.name = gblWindowName;

    document.title = "Survol " + NiceHostname();
} // RunAfterLoad

// Call function after page load: http://stackoverflow.com/questions/890090/jquery-call-function-after-load
$(RunAfterLoad);


/*
http://bl.ocks.org/GerHobbelt/3669455
Rester dans la partie visible : Voir la fonction.
RDF doit passer la contrainte sur les proprietes: Ajouter des triplets RDF qui expriment le layout hierarchique:
"Layout"  property  "valeur"
Mais il n est pas certain que ca suffise quand on a beaucoup d'objets.
*/


/*
https://stackoverflow.com/questions/36841013/custom-force-directed-symbols-in-d3-tables-as-nodes
SVG has a group element that you can use to organize what can be an arbitrarily complex node.
Also, you don't have to use an SVG. You can use D3 to manipulate say, the absolute positioning of HTML table elements.
Ajouter le lien de merge.
*/

</script>

    <title>Survol</title>

</head>

<body>


<table border="0" width="100%"><tr>
    <td><a href="index.htm">Survol</a> <i>Unearthing LegacyWare. Based on CIM/WMI/WBEM, with a web ui. &copy; <a href="http://www.primhillcomputers.com">Primhill Computers</a> 2017</i></td>
    <td align="right"><a href="#" id="IdHrefSummary">Tools</a>&nbsp;
    <a href="#" id="IdPrintLayout">SVG</a>
    <a href="#" id="IdHtmlLayout">HTML</a>
    <a href="#" id="IdConfigurationUrl">Setup</a>
<a href="help.htm">Help</a>
    </td>
</tr></table>

</body>
</html>
