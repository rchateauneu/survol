<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Consulting</title></head>
<body><h2>Docker and dockerizing. </h2>Docker creates lighweight,
portable and self-sufficient containers for
applications, alowing them to run on a cloud. Dockerizing an
application means converting it into a docker container image, to run
within a Docker container. A docker container image is a stand-alone
package of a software including everything needed to run it: code,
runtime, tools, libraries, settings. The process of dockerizing is
creating a Dockerfile, which is a Docker specification text document
that contains all the commands a user could call on the command line to
assemble an image.<br><br>Dockerizing needs knowledge of the internal strctures of
the application to dockerize: The more strategic it is for the Company,
the more complex, with a long technical history and many different
technologies involved, undocumented, obscure. This makes estimation in
price and complexity, as in legacy code, really difficult because
experts of all domains are needed from the start.<br><br><h2>DockIT.</h2><br>DockIT &nbsp;is an open source command line tool to help converting legacy applications into docker container images. <br><br><br>
From a running process, its executions logs and traces, DockIT generates a 
Dockerfile, the configuration file containing all the commands 
Docker need to build its container image.<br>
<br>
DockIT goes beyond analysing runtime dependencies on a static 
application: It analyses this application when it is running. Also, it 
does not need the source code. Specifically, it can work with any binary
 program, whatever its programming language.<br>
<br><br>
Depending on the difficulty of the target applicationanalysed batch,
this file can be just a draft or a complete enumeration of the
resources to dockerize. What it does is the detection of all resources,
languages, libraries created or accessed by an application and any of
its sub-components, during execution. For example:<br>
- Enumerating files: It is able to classify log files and give a hint of
 where they should be moved. It is also able to detect which files are 
used by several processes. For examples, log files are detected as such.<br>
- Called libraries and only these ones<br>
- Subprocesses created, and their executables.<br>
- Environment variables used internally.<br>
- Network port numbers.<br><br>
Also, it is able to analyse a running batch without stopping it.<br>
<br>It means that you do not need any documentation or expert of any
domain, to have an accurate description of all IT resources needed by
the target application, and this result is returned into a clear,
standard and documented Dockerfile, than you can refine to adjust to
your needs.<br><br>You do not have to spend days analysing an
application, to know what is needed to dockerize it: You just need to
briefly monitor it with DockIT:<br><br>- Many tedious tasks are done automatically.<br>
- The generated images can be much smaller, because all the required libraries are given.<br>
- You can focus on the really difficult tasks of dockerizing an application.<br>- You do not need to be skills in all technologies used by your application: DockIT tells what is required.<br>- Less skills are needed<br>- Si script bien cache dans un coin, difficile a debusquer.<br>- Elimine les surprises, notamment avant de prendre la decision de dockeriser.<br>-
Ameliore la precision de vos estimations car repere immediatement les
difficultes et les points techniques a resoudre, et donne des elements
pour les resoudre. Ameliore votre productivite.<br><br>(SURVOL AUSSI: Permet de tater le terrain avant de commencer un developpement)<br><br>When discovering a legacy applicaiton you know nothing about, DockIT gives the significant advantage of understanding the overall structure of a batch process.<br>
<br>
<br>
Helps treating special situation: <br>
- detection of log files, when an application logs to files instead of 
terminal standard output or error. Therefore the right strategy to 
handle logs can be applied: Inside / &nbsp;outside the container, centralized
 logging system etc&#8230;.<br><br><h2>Competition ? No competition.</h2><br>There
are several tools whose aim is also automatizing the dockerization of
applications. They all have their pro and cons, addressing the same
problem with very different technologies: <br> Static code analysis, focusing on some languages etc...
DockIT uses a different techniques which gives results that cannot be
obtained with other tools.
This is really fine, because these tools and DockIT are quite
complementary.
And this is why we have an option to edit a Dockerfile, adding to its
what is missing and was not detected before.<br><br>Generally
speaking: One can edit an existing Dockerfile and add the extra
information it has detected. Or merge it with another Dockerfile.<br><br>
<a href="https://www.ellexus.com/products/breeze-docker-gen/" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=https://www.ellexus.com/products/breeze-docker-gen/&amp;source=gmail&amp;ust=1524249837127000&amp;usg=AFQjCNGnejbkRF0nxKpB1I2ko10cTsszmA" rel="noreferrer" target="_blank">https://www.ellexus.com/<wbr>products/breeze-docker-gen/</a><br>
<a href="http://jasonwilder.com/projects/" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=http://jasonwilder.com/projects/&amp;source=gmail&amp;ust=1524249837127000&amp;usg=AFQjCNFwoykW5DvKmLpwyQS-dKCamp7dkw" rel="noreferrer" target="_blank">http://jasonwilder.com/<wbr>projects/</a><br>
<a href="http://jrruethe.github.io/blog/2015/09/20/dockerfile-generator/" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=http://jrruethe.github.io/blog/2015/09/20/dockerfile-generator/&amp;source=gmail&amp;ust=1524249837127000&amp;usg=AFQjCNFYAJUTkVxn7JlXYniEoXDOMtCJrQ" rel="noreferrer" target="_blank">http://jrruethe.github.io/<wbr>blog/2015/09/20/dockerfile-<wbr>generator/</a><br>
<a href="http://www.startwithdocker.com/" data-saferedirecturl="https://www.google.com/url?hl=en&amp;q=http://www.startwithdocker.com/&amp;source=gmail&amp;ust=1524249837127000&amp;usg=AFQjCNEHth2Z01tQyXTNx1bcsyxyXvbGjA" rel="noreferrer" target="_blank">http://www.startwithdocker.<wbr>com/</a><br><br><br><h2>Platform:</h2>At the moment, DockIT runs exclusively on Linux. A port to Windows will come soon.<h2>And Survol ?</h2>DockIT&nbsp;is
a distinct tool from Survol. Internally, they handle the same type of
objects and resources as described by the CIM industrial standard.
Survol and&nbsp;DockIT are two orthogonal technologies, based on the
same concepts, to address, understand and running applications in-situ
and in-vivo. Survol displays snapshots, whereas DockIT traces a
temporal behaviour on a time scale. <br><br>==<br><br>&nbsp;DockIT&nbsp; is a utility to recondition legacy applications in docker containers.<br><br>It is able to generate Docker configuration files from running process, executions logs and traces.<br><br>It embraces a complete batch or group of processes and generates a Dockerfile draft to move this batch to the Cloud.<br><br>The
typical use case for dockerize is when you have an application that has
one or more configuration files and you would like to control some of
the values using environment variables.<br><br>For example, a Python
application using Sqlalchemy might not be able to use environment
variables directly. It may require that the database URL be read from a
python settings file with a variable named SQLALCHEMY_DATABASE_URI.
dockerize allows you to set an environment variable such as
DATABASE_URL and update the python file when the container starts. In
addition, it can also delay the starting of the python application
until the database container is running and listening on the TCP port.<br><br>Another
use case is when the application logs to specific files on the
filesystem and not stdout or stderr. This makes it difficult to
troubleshoot the container using the docker logs command. For example,
nginx will log to /var/log/nginx/access.logand /var/log/nginx/error.log
by default. While you can sometimes work around this, it's tedious to
find a solution for every application. dockerize allows you to specify
which logs files should be tailed and where they should be sent.<br><br>&nbsp;<br><br>&nbsp;<br><br>http://jasonwilder.com/projects/<br><br>&nbsp;<br><br>&nbsp;<br><br>&nbsp;<br><br>Depending
on the analysed batch, this skeleton can be just a draft or a complete
enumeration of the resources to dockerize. What is certain is that it
makes many details of this tasks much easier and reliable. For example:<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enumerating port numbers.<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Enumerating files: It is able to classify log files and give a hint of
where they should be moved. It is also able to detect which files are
used by several processes. For examples, log files are detected as such.<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Used libraries and only these ones<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subprocesses created.<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Environment variables used internally.<br><br>&nbsp;<br><br>Also, it is able to analyse a running batch without stopping it.<br><br>&nbsp;<br><br>Benefits:<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Many tedious tasks are done automatically.<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The generated images can be much smaller.<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
You can focus on the really difficult tasks of dockerizing an
application.<br><br>&nbsp;<br><br>&nbsp;<br><br>Helps treating special situation:<br><br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
detection of log files, when an application logs to files instead of
terminal standard output or error. Therefore the right strategy to
handle logs can be applied: Inside /&nbsp; outside the container,
centralized logging system etc&#8230;.<br>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><br>&nbsp;<br><br>ð&nbsp; TODO: DECRIRE COMMENTUN FICHIER EST ACCEDE PAR UN PROCESS: READ/WRITE/APPEND, POUR DEDUIRE SI FICHIER LOG ETC&#8230;<br><br>ð&nbsp; AUTREMENT DIT, AU LIEU DE STOCKER UN LIST DE FICHIER, ON STOCKE UNE MAP AVEC DES META-DATA D&#8217;ACCES : RD/RD/APP/<br><br>&nbsp;<br><br>LOG FILE : Que des writes, aucun read, aucun fseek ou bien a la fin.<br><br>Indiquer S&#8217;il y a beaucoup de fseek et donc si ca vaut la peine d utiliser un ssd.<br><br>




</body></html>